// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
#include <vespa/fastos/fastos.h>
#include <vespa/document/bucket/bucketselector.h>

#include <algorithm>
#include <vespa/document/bucket/bucketidfactory.h>
#include <vespa/document/base/documentid.h>
#include <vespa/document/base/idstring.h>
#include <vespa/document/select/node.h>
#include <vespa/document/select/valuenode.h>
#include <vespa/document/select/visitor.h>
#include <vespa/document/select/branch.h>
#include <vespa/document/select/compare.h>

namespace document {

using namespace document::select;

//namespace {
    /**
     * Visitor class that is used for visiting a node tree generated by a
     * document selection expression.
     *
     * The visitor class contains the set of buckets expression can match.
     */
    struct BucketVisitor : public document::select::Visitor {
        const BucketIdFactory& _factory;
        std::vector<BucketId> _buckets;
            // If set to false, the buckets to visit is set in _buckets.
        bool _unknown;

        BucketVisitor(const BucketIdFactory& factory)
            : _factory(factory), _buckets(), _unknown(true) {}

        void visitAndBranch(const document::select::And& node) {
            BucketVisitor left(_factory);
            node.getLeft().visit(left);
            node.getRight().visit(*this);
                // If either part is unknown we can just return other part.
            if (left._unknown) {
                return;
            }
                // If only left part is known return that part.
            if (_unknown) {
                _buckets.swap(left._buckets);
                _unknown = false;
                return;
            }
            std::vector<BucketId> result;
            std::set_intersection(left._buckets.begin(), left._buckets.end(),
                                  _buckets.begin(), _buckets.end(),
                                  back_inserter(result));
            _buckets.swap(result);
            return;
        }

        void visitOrBranch(const document::select::Or& node) {
            BucketVisitor left(_factory);
            node.getLeft().visit(left);
            node.getRight().visit(*this);
                // If one part is unknown we have to keep unknown status
            if (left._unknown || _unknown) {
                _unknown = true;
                return;
            }
                // If both parts are known return both sets
            std::vector<BucketId> result;
            std::set_union(left._buckets.begin(), left._buckets.end(),
                           _buckets.begin(), _buckets.end(),
                           back_inserter(result));
            _buckets.swap(result);
        }

        void visitNotBranch(const document::select::Not&) {
            // Since selected locations doesn't include everything at that
            // location, we can't reverse the selection. Any NOT branch must
            // end up specifying all
        }

        void compare(const select::IdValueNode& node,
                     const select::ValueNode& valnode,
                     const select::Operator& op)
        {
            if (node.getType() == IdValueNode::ALL) {
                const StringValueNode* val(
                        dynamic_cast<const StringValueNode*>(&valnode));
                if (!val) return;
                vespalib::string docId(val->getValue());
                if (op == FunctionOperator::EQ ||
                    !GlobOperator::containsVariables(docId))
                {
                    IdString::UP id(IdString::createIdString(docId));
                    _buckets.push_back(BucketId(58, id->getLocation()));
                    _unknown = false;
                }
            } else if (node.getType() == IdValueNode::USER) {
                const IntegerValueNode* val(
                        dynamic_cast<const IntegerValueNode*>(&valnode));
                if (!val) return;
                UserDocIdString id(vespalib::make_string("userdoc::%lu:", val->getValue()));
                _buckets.push_back(BucketId(32, id.getLocation()));
                _unknown = false;
            } else if (node.getType() == IdValueNode::GROUP) {
                const StringValueNode* val(
                        dynamic_cast<const StringValueNode*>(&valnode));
                if (!val) return;
                vespalib::string group(val->getValue());
                if (op == FunctionOperator::EQ ||
                    !GlobOperator::containsVariables(group))
                {
                    GroupDocIdString id("groupdoc::" + group + ":");
                    _buckets.push_back(BucketId(32, id.getLocation()));
                    _unknown = false;
                }
            } else if (node.getType() == IdValueNode::GID) {
                const StringValueNode* val(
                        dynamic_cast<const StringValueNode*>(&valnode));

                vespalib::string gid(val->getValue());
                if (op == FunctionOperator::EQ ||
                    !GlobOperator::containsVariables(gid))
                {
                    BucketId bid = document::GlobalId::parse(gid).convertToBucketId();
                    _buckets.push_back(BucketId(32, bid.getRawId()));
                    _unknown = false;
                }
            } else if (node.getType() == IdValueNode::BUCKET) {
                const IntegerValueNode* val(
                        dynamic_cast<const IntegerValueNode*>(&valnode));
                if (!val) return;

                BucketId bid(val->getValue());
                if (!bid.getUsedBits()) {
                    bid.setUsedBits(32);
                }
                _buckets.push_back(bid);
                _unknown = false;
            }
        }

        void compare(const select::SearchColumnValueNode& node,
                     const select::ValueNode& valnode,
                     const select::Operator& op) {
            if (op == FunctionOperator::EQ || op == document::select::GlobOperator::GLOB) {
                int bucketCount = 1 << 16;
                const IntegerValueNode* val(
                        dynamic_cast<const IntegerValueNode*>(&valnode));

                int64_t rval = val->getValue();

                for (int i = 0; i < bucketCount; i++) {
                    int64_t column = node.getValue(BucketId(16, i));
                    if (column == rval) {
                        _buckets.push_back(BucketId(16, i));
                    }
                }

                _unknown = false;
            }
        }

        void visitComparison(const document::select::Compare& node) {
            if (node.getOperator() != document::select::FunctionOperator::EQ &&
                node.getOperator() != document::select::GlobOperator::GLOB)
            {
                return;
            }
            const IdValueNode* lid(dynamic_cast<const IdValueNode*>(
                        &node.getLeft()));
            const SearchColumnValueNode* sc(dynamic_cast<const SearchColumnValueNode*>(
                                                    &node.getLeft()));
            if (lid) {
                compare(*lid, node.getRight(), node.getOperator());
            } else if (sc) {
                compare(*sc, node.getRight(), node.getOperator());
            } else {
                const IdValueNode* rid(dynamic_cast<const IdValueNode*>(
                            &node.getRight()));
                if (rid) {
                    compare(*rid, node.getLeft(), node.getOperator());
                }
            }
        }

        void visitConstant(const document::select::Constant&) {
        }

        virtual void
        visitInvalidConstant(const document::select::InvalidConstant &)
        {
        }

        void visitDocumentType(const document::select::DocType&) {
        }

        virtual void
        visitArithmeticValueNode(const ArithmeticValueNode &)
        {
        }

        virtual void
        visitFunctionValueNode(const FunctionValueNode &)
        {
        }

        virtual void
        visitIdValueNode(const IdValueNode &)
        {
        }

        virtual void
        visitSearchColumnValueNode(const SearchColumnValueNode &)
        {
        }

        virtual void
        visitFieldValueNode(const FieldValueNode &)
        {
        }

        virtual void
        visitFloatValueNode(const FloatValueNode &)
        {
        }

        virtual void
        visitVariableValueNode(const VariableValueNode &)
        {
        }

        virtual void
        visitIntegerValueNode(const IntegerValueNode &)
        {
        }

        virtual void
        visitCurrentTimeValueNode(const CurrentTimeValueNode &)
        {
        }

        virtual void
        visitStringValueNode(const StringValueNode &)
        {
        }

        virtual void
        visitNullValueNode(const NullValueNode &)
        {
        }

        virtual void
        visitInvalidValueNode(const InvalidValueNode &)
        {
        }
    };
//}

BucketSelector::BucketSelector(const document::BucketIdFactory& factory)
    : _factory(factory)
{
}

std::unique_ptr<BucketSelector::BucketVector>
BucketSelector::select(const document::select::Node& expression) const
{
    BucketVisitor v(_factory);
    expression.visit(v);
    return std::unique_ptr<BucketVector>(v._unknown
            ? 0 : new BucketVector(v._buckets));
}

} // document
