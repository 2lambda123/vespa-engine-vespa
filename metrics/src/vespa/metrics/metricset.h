// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
/**
 * \class metrics::MetricSet
 * \ingroup metrics
 *
 * \brief Class containing a set of metrics.
 *
 * This is a class to bundle related metrics. Note that the metricsset is
 * itself a metric so this generates a tree where metricssets are leaf nodes.
 */
#pragma once

#include <map>
#include <vespa/metrics/metric.h>

namespace metrics {

class MetricSet : public Metric
{
    std::vector<Metric*> _metricOrder; // Keep added order for reporting
    bool _registrationAltered; // Set to true if metrics have been
                               // registered/unregistered since last time
                               // it was reset
    std::string _dimensionKey; // If this metric is part of a dimension (yamas-speak),
                               // the key of the dimension should be set here.
                               // If so, the name of the metric is used as dimension value.

public:
    typedef std::unique_ptr<MetricSet> UP;
    typedef std::shared_ptr<MetricSet> SP;

    MetricSet(const String& name, const String& tags,
              const String& description, MetricSet* owner = 0,
              const std::string& dimensionKey = "");

    MetricSet(const String& name, Tags dimensions,
              const String& description, MetricSet* owner = 0);

    MetricSet(const MetricSet&, std::vector<Metric::LP>& ownerList,
              CopyType, MetricSet* owner = 0, bool includeUnused = false);
    virtual ~MetricSet() {}

    // If no path, this metric is not registered within another
    bool isTopSet() const { return _owner == 0; }

    /**
     * Returns true if registration has been altered since it was last
     * cleared. Used by the metric manager to know when it needs to recalculate
     * which consumers will see what.
     */
    bool isRegistrationAltered() const { return _registrationAltered; }
    /** Clear all registration altered flags. */
    void clearRegistrationAltered();

    void registerMetric(Metric& m);
    void unregisterMetric(Metric& m);

    virtual Metric* clone(std::vector<Metric::LP>& ownerList,
                          CopyType type, MetricSet* owner,
                          bool includeUnused = false) const
        { return new MetricSet(*this, ownerList, type, owner, includeUnused); }

    void reset();

    virtual bool visit(MetricVisitor&, bool tagAsAutoGenerated = false) const;

    virtual bool logEvent(const String& fullName) const;

    virtual void print(std::ostream&, bool verbose,
                       const std::string& indent, uint64_t secondsPassed) const;

    // These should never be called on metrics set.
    virtual int64_t getLongValue(const stringref & id) const
    { (void) id; assert(false); return 0; }
    virtual double getDoubleValue(const stringref & id) const
    { (void) id; assert(false); return 0; }

    const Metric* getMetric(const String& name) const;
    Metric* getMetric(const String& name) {
        return const_cast<Metric*>(
                const_cast<const MetricSet*>(this)->getMetric(name));
    }

    virtual void addToSnapshot(Metric& m, std::vector<Metric::LP>& o) const
        { addTo(m, &o); }

    const std::vector<Metric*>& getRegisteredMetrics() const
        { return _metricOrder; }

    virtual bool used() const;

    virtual void addMemoryUsage(MemoryConsumption&) const;

    /** Update names using the given name hash, to utilize ref counting. */
    virtual void updateNames(NameHash&) const;

    virtual void printDebug(std::ostream&, const std::string& indent="") const;

    virtual bool isMetricSet() const { return true; }

    virtual void addToPart(Metric& m) const
        { addTo(m, 0); }

    /**
     * Returns the key of the dimension this metric is part of (if any).
     */
    const std::string& getDimensionKey() const { return _dimensionKey; }

private:
        // Do not generate default copy constructor or assignment operator
        // These would screw up metric registering
    MetricSet(const MetricSet&);
    MetricSet& operator=(const MetricSet&);

    void tagRegistrationAltered();
    const Metric* getMetricInternal(const String& name) const;

    virtual void addTo(Metric&, std::vector<Metric::LP>* ownerList) const;
};

} // metrics

