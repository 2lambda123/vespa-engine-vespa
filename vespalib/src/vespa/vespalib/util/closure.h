// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
// This file was generated by the gen_closure.py script.

#pragma once

#include <memory>

namespace vespalib {

// Interfaces -----------------------------------------------------------------

/** Interface of closures that take no arguments. */
template <typename R = void>
struct Closure0 {
    typedef std::unique_ptr<Closure0<R> > UP;

    virtual ~Closure0() {}

    virtual R call() = 0;
};
typedef Closure0<void> Closure;

/** Interface of closures that take one argument. */
template <typename P1, typename R = void>
struct Closure1 {
    typedef std::unique_ptr<Closure1<P1, R> > UP;

    virtual ~Closure1() {}

    virtual R call(P1 param1) = 0;
};

/** Interface of closures that take two arguments. */
template <typename P1, typename P2, typename R = void>
struct Closure2 {
    typedef std::unique_ptr<Closure2<P1, P2, R> > UP;

    virtual ~Closure2() {}

    virtual R call(P1 param1, P2 param2) = 0;
};

/** Interface of closures that take three arguments. */
template <typename P1, typename P2, typename P3, typename R = void>
struct Closure3 {
    typedef std::unique_ptr<Closure3<P1, P2, P3, R> > UP;

    virtual ~Closure3() {}

    virtual R call(P1 param1, P2 param2, P3 param3) = 0;
};

/** Interface of closures that take four arguments. */
template <typename P1, typename P2, typename P3, typename P4, typename R = void>
struct Closure4 {
    typedef std::unique_ptr<Closure4<P1, P2, P3, P4, R> > UP;

    virtual ~Closure4() {}

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) = 0;
};

// Closure0 -------------------------------------------------------------------

/** Implementation of Closure0 binding no arguments to a free function. */
template <typename R>
class Closure0_0 : public Closure0<R> {
    typedef R (*Func)();

    Func _func;

    virtual R call() override
    { return _func(); }

public:
    Closure0_0(Func func)
        : _func(func) {}
};

/** Implementation of Closure0 binding one argument to a free function. */
template <typename T1, typename R>
class Closure0_1 : public Closure0<R> {
    typedef R (*Func)(T1);

    Func _func;
    T1 _arg1;

    virtual R call() override
    { return _func(std::move(_arg1)); }

public:
    Closure0_1(Func func, T1 &&arg1)
        : _func(func), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure0 binding two arguments to a free function. */
template <typename T1, typename T2, typename R>
class Closure0_2 : public Closure0<R> {
    typedef R (*Func)(T1, T2);

    Func _func;
    T1 _arg1;
    T2 _arg2;

    R call() override { return _func(std::move(_arg1), std::move(_arg2)); }
public:
    Closure0_2(Func func, T1 &&arg1, T2 &&arg2)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure0 binding three arguments to a free function. */
template <typename T1, typename T2, typename T3, typename R>
class Closure0_3 : public Closure0<R> {
    typedef R (*Func)(T1, T2, T3);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    R call() override { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3)); }

public:
    Closure0_3(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure0 binding four arguments to a free function. */
template <typename T1, typename T2, typename T3, typename T4, typename R>
class Closure0_4 : public Closure0<R> {
    typedef R (*Func)(T1, T2, T3, T4);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call() override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4)); }

public:
    Closure0_4(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3, T4 &&arg4)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// MemberClosure0 -------------------------------------------------------------

/** Implementation of Closure0 binding no arguments to a member function. */
template <class Ptr, class Obj, typename R>
class MemberClosure0_0 : public Closure0<R> {
    typedef R (Obj::*MemFun)();

    Ptr _ptr;
    MemFun _mem_fun;

    virtual R call() override
    { return ((*_ptr).*_mem_fun)(); }

public:
    MemberClosure0_0(Ptr ptr, MemFun mem_fun)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun) {}
};

/** Implementation of Closure0 binding one argument to a member function. */
template <class Ptr, class Obj, typename T1, typename R>
class MemberClosure0_1 : public Closure0<R> {
    typedef R (Obj::*MemFun)(T1);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;

    R call() override { return ((*_ptr).*_mem_fun)(std::move(_arg1)); }

public:
    MemberClosure0_1(Ptr ptr, MemFun mem_fun, T1 arg1)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure0 binding two arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename R>
class MemberClosure0_2 : public Closure0<R> {
    typedef R (Obj::*MemFun)(T1, T2);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;

    R call() override { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2)); }

public:
    MemberClosure0_2(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure0 binding three arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename R>
class MemberClosure0_3 : public Closure0<R> {
    typedef R (Obj::*MemFun)(T1, T2, T3);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call() override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3)); }

public:
    MemberClosure0_3(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure0 binding four arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename R>
class MemberClosure0_4 : public Closure0<R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, T4);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call() override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4)); }

public:
    MemberClosure0_4(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// Closure1 -------------------------------------------------------------------

/** Implementation of Closure1 binding no arguments to a free function. */
template <typename P1, typename R>
class Closure1_0 : public Closure1<P1, R> {
    typedef R (*Func)(P1);

    Func _func;

    virtual R call(P1 param1) override
    { return _func(std::move(param1)); }

public:
    Closure1_0(Func func)
        : _func(func) {}
};

/** Implementation of Closure1 binding one argument to a free function. */
template <typename T1, typename P1, typename R>
class Closure1_1 : public Closure1<P1, R> {
    typedef R (*Func)(T1, P1);

    Func _func;
    T1 _arg1;

    virtual R call(P1 param1) override
    { return _func(std::move(_arg1), std::move(param1)); }

public:
    Closure1_1(Func func, T1 &&arg1)
        : _func(func), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure1 binding two arguments to a free function. */
template <typename T1, typename T2, typename P1, typename R>
class Closure1_2 : public Closure1<P1, R> {
    typedef R (*Func)(T1, T2, P1);

    Func _func;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(param1)); }

public:
    Closure1_2(Func func, T1 &&arg1, T2 &&arg2)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure1 binding three arguments to a free function. */
template <typename T1, typename T2, typename T3, typename P1, typename R>
class Closure1_3 : public Closure1<P1, R> {
    typedef R (*Func)(T1, T2, T3, P1);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1)); }

public:
    Closure1_3(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure1 binding four arguments to a free function. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename R>
class Closure1_4 : public Closure1<P1, R> {
    typedef R (*Func)(T1, T2, T3, T4, P1);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1)); }

public:
    Closure1_4(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3, T4 &&arg4)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// MemberClosure1 -------------------------------------------------------------

/** Implementation of Closure1 binding no arguments to a member function. */
template <class Ptr, class Obj, typename P1, typename R>
class MemberClosure1_0 : public Closure1<P1, R> {
    typedef R (Obj::*MemFun)(P1);

    Ptr _ptr;
    MemFun _mem_fun;

    virtual R call(P1 param1) override
    { return ((*_ptr).*_mem_fun)(std::move(param1)); }

public:
    MemberClosure1_0(Ptr ptr, MemFun mem_fun)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun) {}
};

/** Implementation of Closure1 binding one argument to a member function. */
template <class Ptr, class Obj, typename T1, typename P1, typename R>
class MemberClosure1_1 : public Closure1<P1, R> {
    typedef R (Obj::*MemFun)(T1, P1);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;

    virtual R call(P1 param1) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(param1)); }

public:
    MemberClosure1_1(Ptr ptr, MemFun mem_fun, T1 arg1)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure1 binding two arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename R>
class MemberClosure1_2 : public Closure1<P1, R> {
    typedef R (Obj::*MemFun)(T1, T2, P1);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(param1)); }

public:
    MemberClosure1_2(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure1 binding three arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename R>
class MemberClosure1_3 : public Closure1<P1, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, P1);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1)); }

public:
    MemberClosure1_3(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure1 binding four arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename R>
class MemberClosure1_4 : public Closure1<P1, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, T4, P1);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1)); }

public:
    MemberClosure1_4(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// Closure2 -------------------------------------------------------------------

/** Implementation of Closure2 binding no arguments to a free function. */
template <typename P1, typename P2, typename R>
class Closure2_0 : public Closure2<P1, P2, R> {
    typedef R (*Func)(P1, P2);

    Func _func;

    virtual R call(P1 param1, P2 param2) override
    { return _func(std::move(param1), std::move(param2)); }

public:
    Closure2_0(Func func)
        : _func(func) {}
};

/** Implementation of Closure2 binding one argument to a free function. */
template <typename T1, typename P1, typename P2, typename R>
class Closure2_1 : public Closure2<P1, P2, R> {
    typedef R (*Func)(T1, P1, P2);

    Func _func;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2) override
    { return _func(std::move(_arg1), std::move(param1), std::move(param2)); }

public:
    Closure2_1(Func func, T1 &&arg1)
        : _func(func), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure2 binding two arguments to a free function. */
template <typename T1, typename T2, typename P1, typename P2, typename R>
class Closure2_2 : public Closure2<P1, P2, R> {
    typedef R (*Func)(T1, T2, P1, P2);

    Func _func;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2)); }

public:
    Closure2_2(Func func, T1 &&arg1, T2 &&arg2)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure2 binding three arguments to a free function. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename R>
class Closure2_3 : public Closure2<P1, P2, R> {
    typedef R (*Func)(T1, T2, T3, P1, P2);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2)); }

public:
    Closure2_3(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure2 binding four arguments to a free function. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename R>
class Closure2_4 : public Closure2<P1, P2, R> {
    typedef R (*Func)(T1, T2, T3, T4, P1, P2);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2)); }

public:
    Closure2_4(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3, T4 &&arg4)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// MemberClosure2 -------------------------------------------------------------

/** Implementation of Closure2 binding no arguments to a member function. */
template <class Ptr, class Obj, typename P1, typename P2, typename R>
class MemberClosure2_0 : public Closure2<P1, P2, R> {
    typedef R (Obj::*MemFun)(P1, P2);

    Ptr _ptr;
    MemFun _mem_fun;

    virtual R call(P1 param1, P2 param2) override
    { return ((*_ptr).*_mem_fun)(std::move(param1), std::move(param2)); }

public:
    MemberClosure2_0(Ptr ptr, MemFun mem_fun)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun) {}
};

/** Implementation of Closure2 binding one argument to a member function. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename R>
class MemberClosure2_1 : public Closure2<P1, P2, R> {
    typedef R (Obj::*MemFun)(T1, P1, P2);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(param1), std::move(param2)); }

public:
    MemberClosure2_1(Ptr ptr, MemFun mem_fun, T1 arg1)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure2 binding two arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename R>
class MemberClosure2_2 : public Closure2<P1, P2, R> {
    typedef R (Obj::*MemFun)(T1, T2, P1, P2);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2)); }

public:
    MemberClosure2_2(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure2 binding three arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename R>
class MemberClosure2_3 : public Closure2<P1, P2, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, P1, P2);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2)); }

public:
    MemberClosure2_3(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure2 binding four arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename R>
class MemberClosure2_4 : public Closure2<P1, P2, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, T4, P1, P2);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2)); }

public:
    MemberClosure2_4(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// Closure3 -------------------------------------------------------------------

/** Implementation of Closure3 binding no arguments to a free function. */
template <typename P1, typename P2, typename P3, typename R>
class Closure3_0 : public Closure3<P1, P2, P3, R> {
    typedef R (*Func)(P1, P2, P3);

    Func _func;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return _func(std::move(param1), std::move(param2), std::move(param3)); }

public:
    Closure3_0(Func func)
        : _func(func) {}
};

/** Implementation of Closure3 binding one argument to a free function. */
template <typename T1, typename P1, typename P2, typename P3, typename R>
class Closure3_1 : public Closure3<P1, P2, P3, R> {
    typedef R (*Func)(T1, P1, P2, P3);

    Func _func;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return _func(std::move(_arg1), std::move(param1), std::move(param2), std::move(param3)); }

public:
    Closure3_1(Func func, T1 &&arg1)
        : _func(func), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure3 binding two arguments to a free function. */
template <typename T1, typename T2, typename P1, typename P2, typename P3, typename R>
class Closure3_2 : public Closure3<P1, P2, P3, R> {
    typedef R (*Func)(T1, T2, P1, P2, P3);

    Func _func;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2), std::move(param3)); }

public:
    Closure3_2(Func func, T1 &&arg1, T2 &&arg2)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure3 binding three arguments to a free function. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename R>
class Closure3_3 : public Closure3<P1, P2, P3, R> {
    typedef R (*Func)(T1, T2, T3, P1, P2, P3);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2), std::move(param3)); }

public:
    Closure3_3(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure3 binding four arguments to a free function. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename R>
class Closure3_4 : public Closure3<P1, P2, P3, R> {
    typedef R (*Func)(T1, T2, T3, T4, P1, P2, P3);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2), std::move(param3)); }

public:
    Closure3_4(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3, T4 &&arg4)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// MemberClosure3 -------------------------------------------------------------

/** Implementation of Closure3 binding no arguments to a member function. */
template <class Ptr, class Obj, typename P1, typename P2, typename P3, typename R>
class MemberClosure3_0 : public Closure3<P1, P2, P3, R> {
    typedef R (Obj::*MemFun)(P1, P2, P3);

    Ptr _ptr;
    MemFun _mem_fun;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return ((*_ptr).*_mem_fun)(std::move(param1), std::move(param2), std::move(param3)); }

public:
    MemberClosure3_0(Ptr ptr, MemFun mem_fun)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun) {}
};

/** Implementation of Closure3 binding one argument to a member function. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename P3, typename R>
class MemberClosure3_1 : public Closure3<P1, P2, P3, R> {
    typedef R (Obj::*MemFun)(T1, P1, P2, P3);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(param1), std::move(param2), std::move(param3)); }

public:
    MemberClosure3_1(Ptr ptr, MemFun mem_fun, T1 arg1)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure3 binding two arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename P3, typename R>
class MemberClosure3_2 : public Closure3<P1, P2, P3, R> {
    typedef R (Obj::*MemFun)(T1, T2, P1, P2, P3);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2), std::move(param3)); }

public:
    MemberClosure3_2(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure3 binding three arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename R>
class MemberClosure3_3 : public Closure3<P1, P2, P3, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, P1, P2, P3);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2), std::move(param3)); }

public:
    MemberClosure3_3(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure3 binding four arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename R>
class MemberClosure3_4 : public Closure3<P1, P2, P3, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, T4, P1, P2, P3);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2, P3 param3) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2), std::move(param3)); }

public:
    MemberClosure3_4(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// Closure4 -------------------------------------------------------------------

/** Implementation of Closure4 binding no arguments to a free function. */
template <typename P1, typename P2, typename P3, typename P4, typename R>
class Closure4_0 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (*Func)(P1, P2, P3, P4);

    Func _func;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return _func(std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    Closure4_0(Func func)
        : _func(func) {}
};

/** Implementation of Closure4 binding one argument to a free function. */
template <typename T1, typename P1, typename P2, typename P3, typename P4, typename R>
class Closure4_1 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (*Func)(T1, P1, P2, P3, P4);

    Func _func;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return _func(std::move(_arg1), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    Closure4_1(Func func, T1 &&arg1)
        : _func(func), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure4 binding two arguments to a free function. */
template <typename T1, typename T2, typename P1, typename P2, typename P3, typename P4, typename R>
class Closure4_2 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (*Func)(T1, T2, P1, P2, P3, P4);

    Func _func;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    Closure4_2(Func func, T1 &&arg1, T2 &&arg2)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure4 binding three arguments to a free function. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename P4, typename R>
class Closure4_3 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (*Func)(T1, T2, T3, P1, P2, P3, P4);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    Closure4_3(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure4 binding four arguments to a free function. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename P4, typename R>
class Closure4_4 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (*Func)(T1, T2, T3, T4, P1, P2, P3, P4);

    Func _func;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return _func(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    Closure4_4(Func func, T1 &&arg1, T2 &&arg2, T3 &&arg3, T4 &&arg4)
        : _func(func), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// MemberClosure4 -------------------------------------------------------------

/** Implementation of Closure4 binding no arguments to a member function. */
template <class Ptr, class Obj, typename P1, typename P2, typename P3, typename P4, typename R>
class MemberClosure4_0 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (Obj::*MemFun)(P1, P2, P3, P4);

    Ptr _ptr;
    MemFun _mem_fun;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return ((*_ptr).*_mem_fun)(std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    MemberClosure4_0(Ptr ptr, MemFun mem_fun)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun) {}
};

/** Implementation of Closure4 binding one argument to a member function. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename P3, typename P4, typename R>
class MemberClosure4_1 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (Obj::*MemFun)(T1, P1, P2, P3, P4);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    MemberClosure4_1(Ptr ptr, MemFun mem_fun, T1 arg1)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)) {}
};

/** Implementation of Closure4 binding two arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename P3, typename P4, typename R>
class MemberClosure4_2 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (Obj::*MemFun)(T1, T2, P1, P2, P3, P4);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    MemberClosure4_2(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)) {}
};

/** Implementation of Closure4 binding three arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename P4, typename R>
class MemberClosure4_3 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, P1, P2, P3, P4);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    MemberClosure4_3(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)) {}
};

/** Implementation of Closure4 binding four arguments to a member function. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename P4, typename R>
class MemberClosure4_4 : public Closure4<P1, P2, P3, P4, R> {
    typedef R (Obj::*MemFun)(T1, T2, T3, T4, P1, P2, P3, P4);

    Ptr _ptr;
    MemFun _mem_fun;
    T1 _arg1;
    T2 _arg2;
    T3 _arg3;
    T4 _arg4;

    virtual R call(P1 param1, P2 param2, P3 param3, P4 param4) override
    { return ((*_ptr).*_mem_fun)(std::move(_arg1), std::move(_arg2), std::move(_arg3), std::move(_arg4), std::move(param1), std::move(param2), std::move(param3), std::move(param4)); }

public:
    MemberClosure4_4(Ptr ptr, MemFun mem_fun, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        : _ptr(std::move(ptr)), _mem_fun(mem_fun), _arg1(std::move(arg1)), _arg2(std::move(arg2)), _arg3(std::move(arg3)), _arg4(std::move(arg4)) {}
};

// Function closures (0) ------------------------------------------------------

/** Creates a Closure0 from a free function, binding no arguments. */
template <typename R>
std::unique_ptr<Closure0<R> >
makeClosure(R (*func)()) {
    return std::unique_ptr<Closure0<R> >(
            new Closure0_0<R>(func));
}

/** Creates a Closure0 from a free function, binding one argument. */
template <typename T1, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(R (*func)(T1), T1 arg1) {
    return std::unique_ptr<Closure0<R> >(
            new Closure0_1<T1, R>(func, std::move(arg1)));
}

/** Creates a Closure0 from a free function, binding two arguments. */
template <typename T1, typename T2, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(R (*func)(T1, T2), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure0<R> >(
            new Closure0_2<T1, T2, R>(func, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure0 from a free function, binding three arguments. */
template <typename T1, typename T2, typename T3, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(R (*func)(T1, T2, T3), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure0<R> >(
            new Closure0_3<T1, T2, T3, R>(func, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure0 from a free function, binding four arguments. */
template <typename T1, typename T2, typename T3, typename T4, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(R (*func)(T1, T2, T3, T4), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure0<R> >(
            new Closure0_4<T1, T2, T3, T4, R>(func, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Member closures (0) --------------------------------------------------------

/** Creates a Closure0 from a member function, binding no arguments. */
template <class Ptr, class Obj, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)()) {
    return std::unique_ptr<Closure0<R> >(
            new MemberClosure0_0<Ptr, Obj, R>(
                    std::move(ptr), mem_fun));
}

/** Creates a Closure0 from a member function, binding one argument. */
template <class Ptr, class Obj, typename T1, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1), T1 arg1) {
    return std::unique_ptr<Closure0<R> >(
            new MemberClosure0_1<Ptr, Obj, T1, R>(
                    std::move(ptr), mem_fun, std::move(arg1)));
}

/** Creates a Closure0 from a member function, binding two arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure0<R> >(
            new MemberClosure0_2<Ptr, Obj, T1, T2, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure0 from a member function, binding three arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure0<R> >(
            new MemberClosure0_3<Ptr, Obj, T1, T2, T3, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure0 from a member function, binding four arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename R>
std::unique_ptr<Closure0<R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, T4), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure0<R> >(
            new MemberClosure0_4<Ptr, Obj, T1, T2, T3, T4, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Function closures (1) ------------------------------------------------------

/** Creates a Closure1 from a free function, binding no arguments. */
template <typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(R (*func)(P1)) {
    return std::unique_ptr<Closure1<P1, R> >(
            new Closure1_0<P1, R>(func));
}

/** Creates a Closure1 from a free function, binding one argument. */
template <typename T1, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(R (*func)(T1, P1), T1 arg1) {
    return std::unique_ptr<Closure1<P1, R> >(
            new Closure1_1<T1, P1, R>(func, std::move(arg1)));
}

/** Creates a Closure1 from a free function, binding two arguments. */
template <typename T1, typename T2, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(R (*func)(T1, T2, P1), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure1<P1, R> >(
            new Closure1_2<T1, T2, P1, R>(func, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure1 from a free function, binding three arguments. */
template <typename T1, typename T2, typename T3, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(R (*func)(T1, T2, T3, P1), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure1<P1, R> >(
            new Closure1_3<T1, T2, T3, P1, R>(func, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure1 from a free function, binding four arguments. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(R (*func)(T1, T2, T3, T4, P1), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure1<P1, R> >(
            new Closure1_4<T1, T2, T3, T4, P1, R>(func, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Member closures (1) --------------------------------------------------------

/** Creates a Closure1 from a member function, binding no arguments. */
template <class Ptr, class Obj, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(P1)) {
    return std::unique_ptr<Closure1<P1, R> >(
            new MemberClosure1_0<Ptr, Obj, P1, R>(
                    std::move(ptr), mem_fun));
}

/** Creates a Closure1 from a member function, binding one argument. */
template <class Ptr, class Obj, typename T1, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, P1), T1 arg1) {
    return std::unique_ptr<Closure1<P1, R> >(
            new MemberClosure1_1<Ptr, Obj, T1, P1, R>(
                    std::move(ptr), mem_fun, std::move(arg1)));
}

/** Creates a Closure1 from a member function, binding two arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, P1), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure1<P1, R> >(
            new MemberClosure1_2<Ptr, Obj, T1, T2, P1, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure1 from a member function, binding three arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, P1), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure1<P1, R> >(
            new MemberClosure1_3<Ptr, Obj, T1, T2, T3, P1, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure1 from a member function, binding four arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename R>
std::unique_ptr<Closure1<P1, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, T4, P1), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure1<P1, R> >(
            new MemberClosure1_4<Ptr, Obj, T1, T2, T3, T4, P1, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Function closures (2) ------------------------------------------------------

/** Creates a Closure2 from a free function, binding no arguments. */
template <typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(R (*func)(P1, P2)) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new Closure2_0<P1, P2, R>(func));
}

/** Creates a Closure2 from a free function, binding one argument. */
template <typename T1, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(R (*func)(T1, P1, P2), T1 arg1) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new Closure2_1<T1, P1, P2, R>(func, std::move(arg1)));
}

/** Creates a Closure2 from a free function, binding two arguments. */
template <typename T1, typename T2, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(R (*func)(T1, T2, P1, P2), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new Closure2_2<T1, T2, P1, P2, R>(func, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure2 from a free function, binding three arguments. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(R (*func)(T1, T2, T3, P1, P2), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new Closure2_3<T1, T2, T3, P1, P2, R>(func, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure2 from a free function, binding four arguments. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(R (*func)(T1, T2, T3, T4, P1, P2), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new Closure2_4<T1, T2, T3, T4, P1, P2, R>(func, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Member closures (2) --------------------------------------------------------

/** Creates a Closure2 from a member function, binding no arguments. */
template <class Ptr, class Obj, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(P1, P2)) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new MemberClosure2_0<Ptr, Obj, P1, P2, R>(
                    std::move(ptr), mem_fun));
}

/** Creates a Closure2 from a member function, binding one argument. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, P1, P2), T1 arg1) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new MemberClosure2_1<Ptr, Obj, T1, P1, P2, R>(
                    std::move(ptr), mem_fun, std::move(arg1)));
}

/** Creates a Closure2 from a member function, binding two arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, P1, P2), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new MemberClosure2_2<Ptr, Obj, T1, T2, P1, P2, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure2 from a member function, binding three arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, P1, P2), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new MemberClosure2_3<Ptr, Obj, T1, T2, T3, P1, P2, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure2 from a member function, binding four arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename R>
std::unique_ptr<Closure2<P1, P2, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, T4, P1, P2), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure2<P1, P2, R> >(
            new MemberClosure2_4<Ptr, Obj, T1, T2, T3, T4, P1, P2, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Function closures (3) ------------------------------------------------------

/** Creates a Closure3 from a free function, binding no arguments. */
template <typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(R (*func)(P1, P2, P3)) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new Closure3_0<P1, P2, P3, R>(func));
}

/** Creates a Closure3 from a free function, binding one argument. */
template <typename T1, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(R (*func)(T1, P1, P2, P3), T1 arg1) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new Closure3_1<T1, P1, P2, P3, R>(func, std::move(arg1)));
}

/** Creates a Closure3 from a free function, binding two arguments. */
template <typename T1, typename T2, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(R (*func)(T1, T2, P1, P2, P3), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new Closure3_2<T1, T2, P1, P2, P3, R>(func, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure3 from a free function, binding three arguments. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(R (*func)(T1, T2, T3, P1, P2, P3), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new Closure3_3<T1, T2, T3, P1, P2, P3, R>(func, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure3 from a free function, binding four arguments. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(R (*func)(T1, T2, T3, T4, P1, P2, P3), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new Closure3_4<T1, T2, T3, T4, P1, P2, P3, R>(func, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Member closures (3) --------------------------------------------------------

/** Creates a Closure3 from a member function, binding no arguments. */
template <class Ptr, class Obj, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(P1, P2, P3)) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new MemberClosure3_0<Ptr, Obj, P1, P2, P3, R>(
                    std::move(ptr), mem_fun));
}

/** Creates a Closure3 from a member function, binding one argument. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, P1, P2, P3), T1 arg1) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new MemberClosure3_1<Ptr, Obj, T1, P1, P2, P3, R>(
                    std::move(ptr), mem_fun, std::move(arg1)));
}

/** Creates a Closure3 from a member function, binding two arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, P1, P2, P3), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new MemberClosure3_2<Ptr, Obj, T1, T2, P1, P2, P3, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure3 from a member function, binding three arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, P1, P2, P3), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new MemberClosure3_3<Ptr, Obj, T1, T2, T3, P1, P2, P3, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure3 from a member function, binding four arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename R>
std::unique_ptr<Closure3<P1, P2, P3, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, T4, P1, P2, P3), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure3<P1, P2, P3, R> >(
            new MemberClosure3_4<Ptr, Obj, T1, T2, T3, T4, P1, P2, P3, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Function closures (4) ------------------------------------------------------

/** Creates a Closure4 from a free function, binding no arguments. */
template <typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(R (*func)(P1, P2, P3, P4)) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new Closure4_0<P1, P2, P3, P4, R>(func));
}

/** Creates a Closure4 from a free function, binding one argument. */
template <typename T1, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(R (*func)(T1, P1, P2, P3, P4), T1 arg1) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new Closure4_1<T1, P1, P2, P3, P4, R>(func, std::move(arg1)));
}

/** Creates a Closure4 from a free function, binding two arguments. */
template <typename T1, typename T2, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(R (*func)(T1, T2, P1, P2, P3, P4), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new Closure4_2<T1, T2, P1, P2, P3, P4, R>(func, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure4 from a free function, binding three arguments. */
template <typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(R (*func)(T1, T2, T3, P1, P2, P3, P4), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new Closure4_3<T1, T2, T3, P1, P2, P3, P4, R>(func, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure4 from a free function, binding four arguments. */
template <typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(R (*func)(T1, T2, T3, T4, P1, P2, P3, P4), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new Closure4_4<T1, T2, T3, T4, P1, P2, P3, P4, R>(func, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

// Member closures (4) --------------------------------------------------------

/** Creates a Closure4 from a member function, binding no arguments. */
template <class Ptr, class Obj, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(P1, P2, P3, P4)) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new MemberClosure4_0<Ptr, Obj, P1, P2, P3, P4, R>(
                    std::move(ptr), mem_fun));
}

/** Creates a Closure4 from a member function, binding one argument. */
template <class Ptr, class Obj, typename T1, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, P1, P2, P3, P4), T1 arg1) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new MemberClosure4_1<Ptr, Obj, T1, P1, P2, P3, P4, R>(
                    std::move(ptr), mem_fun, std::move(arg1)));
}

/** Creates a Closure4 from a member function, binding two arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, P1, P2, P3, P4), T1 arg1, T2 arg2) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new MemberClosure4_2<Ptr, Obj, T1, T2, P1, P2, P3, P4, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2)));
}

/** Creates a Closure4 from a member function, binding three arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, P1, P2, P3, P4), T1 arg1, T2 arg2, T3 arg3) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new MemberClosure4_3<Ptr, Obj, T1, T2, T3, P1, P2, P3, P4, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3)));
}

/** Creates a Closure4 from a member function, binding four arguments. */
template <class Ptr, class Obj, typename T1, typename T2, typename T3, typename T4, typename P1, typename P2, typename P3, typename P4, typename R>
std::unique_ptr<Closure4<P1, P2, P3, P4, R> >
makeClosure(Ptr ptr, R (Obj::*mem_fun)(T1, T2, T3, T4, P1, P2, P3, P4), T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return std::unique_ptr<Closure4<P1, P2, P3, P4, R> >(
            new MemberClosure4_4<Ptr, Obj, T1, T2, T3, T4, P1, P2, P3, P4, R>(
                    std::move(ptr), mem_fun, std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)));
}

}  // namespace vespalib


