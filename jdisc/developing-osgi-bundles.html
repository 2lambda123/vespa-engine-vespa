<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root. -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
  <head>
    <link rel="stylesheet" type="text/css" 
          href="http://vespa.corp.yahoo.com/css/vespadoc-standalone.css" />
    <meta name="date" content="May 2016" />
    <meta name="authors" content="gv" />
    <title>Building OSGi bundles for the JDisc Container</title>
  </head>
  
<body>

<p>

The JDisc container uses <a href="http://osgi.org">OSGi</a> to provide a modular platform
for developing applications that can be composed of many reusable components. The user can
deploy, upgrade and remove these components at runtime.

</p>
      
    <h2 id="what-is-osgi">What is OSGi?</h2>
    <p>
      OSGi is a framework for modular development of Java applications, where a
      set of resources called <em>bundles</em> can be installed. OSGi allows the developer to
      control which resources (Java packages) in a bundle that should be available to
      other bundles. Hence, you can explicitly declare a bundle's public API,
      and also ensure that internal implementation details remain hidden.
    </p>
    <p>
      Unless you're already familiar with OSGi, you should read Richard
      S. Hall's presentation on
      <a href="http://felix.apache.org/site/presentations.data/Learning_to_ignore_OSGi.pdf">using
      OSGi as a means to achieve modularity</a>. This presentation explains a
      lot about how OSGi works, and why.

      There are also other
      <a href="http://www.theserverside.com/tt/articles/article.tss?l=OSGiforBeginners">great</a>
      <a href="http://www.eclipse.org/equinox/documents/eclipsist2007/EclipseSummitTurkey2007-OSGiEquinoxExplained.pdf">OSGi</a>
      <a href="http://www.javaworld.com/javaworld/jw-03-2008/jw-03-osgi1.html">guides</a>
      available online.
    </ul>

    <p class="note">
      For those familiar with OSGi, JDisc uses OSGi's <em>module</em> and
      <em>lifecycle</em> layers, and does not provide any functionality from the
      <em>service</em> layer.
    </p>
    
    <h2 id="typical-bundle">What is an OSGi bundle?</h2>

    <p>
    An OSGi bundle is a regular JAR file with a MANIFEST.MF file that describes its content,
    what the bundle requires (imports) from other bundles, and what it provides (exports) to other
    bundles. Below is an example of a typical bundle manifest with the most important headers:
    </p>
    
<pre class="code">
Bundle-SymbolicName: com.yahoo.helloworld
Bundle-Description: A Hello World bundle
Bundle-Version: 1.0.0
Export-Package: com.yahoo.helloworld;version="1.0.0"
Import-Package: org.osgi.framework;version="1.3.0"
</pre>
    <p>
      The meaning of the headers in this bundle manifest is as follows:
    </p>
    <ul>
      <li><code>Bundle-SymbolicName</code> - The unique identifier of the bundle.</li>
      <li><code>Bundle-Description</code> - A human readable description of the bundle's
        functionality.</li>
      <li><code>Bundle-Version</code> - Designates a version number to the
        bundle.</li>
      <li><code>Export-Package</code> - Expresses which Java packages contained
        in a bundle will be made available to the outside world.</li>
      <li><code>Import-Package</code> - Indicates which Java packages will be
        required from the outside world to fulfill the dependencies needed in a
        bundle.</li>
    </ul>
    <p class="note">
      Note that OSGi has a strict definition of version numbers that need to
      be followed for bundles to work correctly.  See the
      <a href="http://www.osgi.org/javadoc/r4v42/org/osgi/framework/Version.html#Version(java.lang.String)">OSGi
      javadoc</a> for details. As a general advice, never use more than three numbers
      in the version (major, minor, micro).
    </p>

    <h2>Building an OSGi bundle</h2>
    <p>
      As long as your project was created by following steps in
      the <a href="developing-applications.html">developing applications</a>
      guide, your code is already being packaged into an OSGi bundle by the
      <a href="bundle-plugin.html">Maven bundle plugin</a>. However, if you are
      migrating an existing Maven project, you need to change your packaging
      statement to
    </p>
<pre class="code">
&lt;packaging&gt;container-plugin&lt;/packaging&gt;
</pre>
    <p>
      and you need to add the plugin to your build instructions
    </p>
<pre class="brush: xml">
&lt;plugin&gt;
    &lt;groupId&gt;com.yahoo.vespa&lt;/groupId&gt;
    &lt;artifactId&gt;bundle-plugin&lt;/artifactId&gt;
    &lt;version&gt;current-version&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
&lt;/plugin&gt;
</pre>
    <p>
      Because OSGi introduces a different runtime environment from what Maven
      provides when running unit tests, you will not observe any loading and
      linking errors until you try to deploy your application onto a running
      JDisc Container. 

      Errors triggered at this stage will be the likes of
      <code>ClassNotFoundException</code> and <code>NoClassDefFoundError</code>. To debug
      these types of errors, you need to inspect the stack traces in the <a
       href="../reference/logs.html">error log</a>, and refer to the <a
       href="osgi-classloading.html">OSGi troubleshooting</a> document </p>


      Remember that the <a href="../reference/logfmt.html">logfmt</a>
      binary with its "--nldequote" option is your friend when reading logs.
    </p>
    <p class="note">
      Your test suite needs to cover deployment of your application bundle to
      ensure that its dynaming loading and linking issues are covered.
    </p>

    <h2>Depending on non-OSGi ready libraries</h2>
    <p>
      Unfortunately, many popular Java libraries have yet to be bundled with the
      appropriate manifest that makes them OSGi-compatible.
      The simplest solution to this is to set the scope of the problematic
      dependency to <strong>compile</strong> in your pom.xml file. This will cause the bundle
      plugin to package the whole library into your bundle's JAR file. Until the 
      offending library becomes available as an OSGi bundle, it means that your
      bundle will be bigger (in number of bytes), and that classes of that 
      library can not be shared across application bundles.
    </p>
    <p class="note">
      The practical implication of this feature is that the bundle plugin
      copies the compile-scoped dependency, and its transitive dependencies,
      into the final JAR file, and adds
      a <code>Bundle-ClassPath</code> instruction to its manifest that 
      references those dependencies.
    </p>
    <p>
      Although this approach works for most non-OSGi libraries, it only works for
      libraries where the jar file is <em>self contained</em>. If, on the other hand, the
      library depends on other installed files, it must be treated as if it was a
      <a href="#jni">JNI library</a>.
    </p>

    <h2 id="jni">Depending on JNI Libraries</h2>
    <p>
      When a library uses the Java Native Interface (JNI), it is crucial that a
      compatible version of the native library is installed on the host. This
      means that even if the Java library is packaged as an OSGi bundle, it is
      unsafe to include the bundle in your application package since there is
      no enforcement of what native libraries are installed on a host.
    </p>
    <p>
      The simplest solution to this is to add the JNI library to the JDisc
      Container's classpath, and to explicitly export its packages to make them visible
      to OSGI bundles. You do this
      by adding the following configuration in the top level 'services'
      element in your
      <a href="../reference/services-jdisc.html">services.xml</a>:
    </p>
<pre class="brush: xml">
&lt;services version="1.0"&gt;
    &lt;config name="search.config.qr-start"&gt;
        &lt;jdisc&gt;
            &lt;classpath_extra&gt;/lib/jars/foo.jar:/path/bar.jar&lt;/classpath_extra&gt;
            &lt;export_packages&gt;com.foo,com.bar&lt;/export_packages&gt;
        &lt;/jdisc&gt;
    &lt;/config&gt;
    ...
&lt;/services&gt;
</pre>

<p>Adding the config at the top level ensures that it's applied to all jdisc clusters.</p>

The packages are now available and visible, but they must still be imported by your
application bundle that uses the library. Here is how to configure the bundle
plugin to enforce an import of the packages to your bundle:
</p>
<pre class="brush: xml">
&lt;plugin&gt;
  &lt;groupId&gt;yahoo.yinst.osgi&lt;/groupId&gt;
  &lt;artifactId&gt;bundle-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  <strong>&lt;configuration&gt;
    &lt;importPackage&gt;com.foo,com.bar&lt;/importPackage&gt;
  &lt;/configuration&gt;</strong>
&lt;/plugin&gt;
</pre>

    <p class="note">
      When adding a library to the classpath it becomes globally visible, and
      exempt from the package visibility management of OSGi. If another bundle
      contains the same library, there will be class loading issues.
    </p>
  </body>
</html>

