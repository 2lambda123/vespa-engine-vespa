<!DOCTYPE html>
<!-- Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root. -->

<html lang="en">

<head>
<title>Search Definitions</title>
<link rel="stylesheet" type="text/css" href="http://vespa.corp.yahoo.com/css/vespadoc-standalone.css" />
<meta name="date"       content="October 2010" />
<meta name="authors"    content="bratseth, bergum, musum" />
</head>

<body>

<p class="ingress">
This document lists the syntax and content of search definitions,
document types and fields. An overview of these concepts is found in
<a
href="../jdisc/application-packages.html#creating_search_definition">search
applications</a>. This is a reference, you should read that
first. Refer also to the <a href="#an_example">example search
definition</a> at the end of this document.
</p>

<div class="alert alert-success">
    <p>If you want to index UUID type fields in Vespa please use the following string type definition.
	<pre>
	field uuid type string {
		indexing: summary | index
		match: word
		rank:filter
	}
	</pre>
</p>
</div>

<p>
Throughout this document, a string put in square brackets stands for
some argument. The whole string, including the brackets is replaced by
a concrete string in a search definition.
</p>

<h1 id="search_definition_syntax">Search definition syntax</h1>

<p>
Constructs in search definitions have a regular syntax. Each element
starts by the element <em>identifier</em>, possibly followed by the
<em>name</em> of this particular occurrence of the element, possibly followed by a
space-separated list of interleaved <em>attribute names</em> and
<em>attribute values</em>,
possibly followed by the <em>element body</em> (yes, it is XML in a
different syntax). Thus, you'll find elements of these varieties:
</p>

<pre>
[element-identifier] : [element-body]
</pre>

<pre>
[element-identifier] [element-name] : [element-body]
</pre>

<pre>
[element-identifier] [element-name] [attribute-name] [attribute-value]
</pre>

<pre>
[element-identifier] [element-name] [attribute-name] [attribute-value] {
    [element-body]
}
</pre>

<p>
Note that one-line element values starts by a colon and ends by
newline. Multiline values (for fields supporting them) are any block
of text enclosed in curly brackets.
</p>

<p>
Comments may be inserted anywhere and start with a hash (#).
</p>


<h1 id="document-definition">Document definitions</h1>
<p>
This sections lists the syntax and content of a document definition,
a subset of a search definition.
</p>

<p class="alert alert-success">
There must be at least one .sd file containing a search element in
an application package, other ones may start with the document
element, as described in this document.
</p>

<p>
The <a href="#search_definition_syntax">syntax</a> is the same as for
a search definition, the <a href="#field_types">valid field types</a>
are the same, but the only other construct meaningful is specifying <a
href="#header_in_field">header</a> or <a
href="#body_in_field">body</a> for a field. The document
definition elements, described in detail below, are:
</p>

<ul>
<li><a href="#body_in_field">body</a></li>
<li><a href="#document">document</a></li>
<li><a href="#field">field</a></li>
<li><a href="#header_in_field">header</a></li>
</ul>


<h1 id="element-index">Search definition element index</h1>

<p>
One .sd file must contain no more than one search clause.
The search definition elements, described in detail below, are:
</p>

<pre>
<a href="#search">search</a>
    <a href="#document">document</a>
        <a href="#struct">struct</a>
            <a href="#field">field</a>
                <a href="#match">match</a>
        <a href="#field">field</a>
            <a href="#alias">alias</a>
            <a href="#attribute">attribute</a>
            <a href="#body_in_field">body</a>
            <a href="#bolding">bolding</a>
            <a href="#header_in_field">header</a>
            <a href="#id">id</a>
            <a href="#index">index</a>
            <a href="#indexing">indexing</a>
            <a href="#indexing-rewrite">indexing-rewrite</a>
            <a href="#match">match</a>
            <a href="#normalizing">normalizing</a>
            <a href="#query-command">query-command</a>
            <a href="#rank">rank</a>
            <a href="#rank-type">rank-type</a>
            <a href="#sorting">sorting</a>
            <a href="#stemming">stemming</a>
            <a href="#struct-field">struct-field</a>
                <a href="#indexing">indexing</a>
                <a href="#match">match</a>
                <a href="#query-command">query-command</a>
                <a href="#struct-field">struct-field</a>
                 &hellip;
                <a href="#summary">summary</a>
                <a href="#summary-to">summary-to</a>
            <a href="#summary">summary</a>
            <a href="#summary-to">summary-to</a>
            <a href="#weight">weight</a>
            <a href="#weightedset">weightedset</a>
        <a href="#compression">compression</a>
        <a href="#header_in_document">header</a>
            <a href="#compression">compression</a>
        <a href="#body_in_document">body</a>
            <a href="#compression">compression</a>
    <a href="#index">index</a>
    <a href="#field">field</a>
    <a href="#fieldset">fieldset</a>
     &hellip;
    <a href="#rank-profile">rank-profile</a>
        <a href="#match-phase">match-phase</a>
            <a href="#match-phase-attribute">attribute</a>
            <a href="#match-phase-order">order</a>
            <a href="#match-phase-max-hits">max-hits</a>
            <a href="#diversity">diversity</a>
                <a href="#diversity-attribute">attribute</a>
                <a href="#diversity-min-groups">min-groups</a>
        <a href="#firstphase-rank">first-phase</a>
            <a href="#keep-rank-count">keep-rank-count</a>
            <a href="#rank-score-drop-limit">rank-score-drop-limit</a>
            <a href="#rankfeatures-expression">expression</a>
        <a href="#ignore-default-rank-features">ignore-default-rank-features</a>
        <a href="#num-threads-per-search">num-threads-per-search</a>
        <a href="#rank">rank</a>
        <a href="#rank-type">rank-type</a>
        <a href="#rankfeatures">rank-features</a>
        <a href="#constants">constants</a>
        <a href="#rankproperties">rank-properties</a>
        <a href="#secondphase-rank">second-phase</a>
            <a href="#rankfeatures-expression">expression</a>
            <a href="#rerank-count">rerank-count</a>
        <a href="#summaryfeatures">summary-features</a>
    <a href="#stemming">stemming</a>
    <a href="#document-summary">document-summary</a>
        <a href="#summary">summary</a>
    <a href="#annotation">annotation</a>
        <a href="#field">field</a>
</pre>



<h1 id="elements">Search definition elements</h1>


<h2 id="search">search</h2>

<p>
The root element of search definitions.  A search definition describes
how some data should be stored, indexed, ranked and presented in
results. A search definition must be defined in a file named
<code>[search-definition-name].sd</code>.
</p>

<pre>
search [name] {
    [body]
}
</pre>

<p>
The body is mandatory and may contain:
</p>

<table>

<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#document">document</a></td>
<td>A document defined in this search definition.</td>
<td>One</td>
</tr>

<tr><td><a href="#field">field</a></td>
<td>A field not contained in the document.
Use fields outside documents when you want to derive new field values
to be placed in the indexing structure from document fields.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#fieldset">fieldset</a></td>
<td>
A field set to provide a way to group document fields together for searching. When you query a field set,
you will get results from all the fields in the field set.
</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#rank-profile">rank-profile</a></td>
<td>An explicitly defined set of ranking settings.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#stemming">stemming</a></td>
<td>The default stemming setting. Default is <code>shortest</code>. <em>Not applicable to streaming search</em></td>
<td>Zero or one</td>
</tr>

<tr><td><a href="#document-summary">document-summary</a></td>
<td>An explicitly defined document summary.</td>
<td>Zero to many</td>
</tr>

</table>




<h2 id="document">document</h2>
<p>
Contained in <code><a href="#search">search</a></code>.
</p>

<p>
Describes a document type. This can also be the root of the search
definition, if the document is not to be searched directly. A document
type may inherit the fields of one or more other document types. If no
document types are explicitly inherited, the document inherits the
generic <code>document</code> type.
</p>

<pre>
document [name] inherits [name-list] {
    [body]
}
</pre>

<p>
The document name is optional, it defaults to the containing <code>search</code>
 element's name. If there is no containing <code>search</code> element, the document name is required.
</p>

<p>
The <code>inherits</code> attribute is optional and has as value a comma-separated
list of names of other document types.
</p>

<p>
The body of a document type is optional and may contain:
</p>

<table> <tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#struct">struct</a></td>
<td>A struct type definition for this document.</td><td>Zero to many</td></tr>

<tr><td><a href="#field">field</a></td><td>A field of this document.
</td><td>Zero to many</td></tr>

<tr><td><a href="#header_in_document">header</a></td>
<td>Configure options for the header part of the document.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#body_in_document">body</a></td>
<td>Configure options for the body part of the document.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#compression">compression</a></td>
<td>Specifies compression options for documents of this document type in storage.</td>
<td>Zero to one</td>
</tr>

</table>


<h2 id="struct">struct</h2>
<p>Contained in <code><a
href="#document">document</a></code>.</p>
 <div class="alert alert-success">
Please note that struct types is not supported by traditional indexed search and the behavior of operations over struct fields is undefined.
</div>
<p>
Defines a composite type. A struct consists of zero or more
fields that the user can access together as one. The struct has to be
defined before it is used as a type in a field specification.</p>

<pre>
struct [name] {
    [body]
}
</pre>

<p>The struct name should not contain any underscores.</p>

<p>The struct element is currently only supported by streaming search.</p>

<p>The body of a struct is optional and may contain:</p>
<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>
<tr><td><a href="#field">field</a></td><td>A field of this struct.
</td><td>Zero to many</td></tr>
</table>


<h2 id="field">field</h2>
<p>Contained in <code><a href="#search">search</a></code>,
<code><a href="#document">document</a></code>,
<code><a href="#struct">struct</a></code> or
<code><a href="#annotation">annotation</a></code>.</p>

<p>Defines a named value with a type and (optionally) how this field
should be stored, indexed, searched, presented and how it should influence
ranking.</p>

<pre>
field [name] type <a href="#field_types">[type-name]</a> {
    [body]
}
</pre>

<p>You should stay away from using names that are used for other
purposes in the indexing language or other places in the search
definition file. The currently reserved names are "summary", "index", "attribute"
"position", "switch", "case", "if", "else", "tokenize", "sddocname",
"relevancy", "hit", "host", "context", "body" and "header". Other
names not to use include any words that start with a
number or includes other special characters and words that match XML tags in the QRS output.</p>

<p>The type attribute is mandatory and has one of the following values:</p>

<table>
<tr><th>Name</th><th>Type</th></tr>
<tr><td><a href="#type:annotationreference">annotationreference&lt;annotationtype&gt;</a></td><td>Declares a reference to an annotation on a given string. Should only be used for fields declared inside <a href="#annotation">annotation</a>, or as a base type by the use of any of the compound types listed above, inside <a href="#annotation">annotation</a>.</td></tr>
<tr><td><a href="#type:array">array&lt;element-type&gt;</a></td><td>An array of <code>element-type</code>. The element type can be any single value type.</td></tr>
<tr><td><a href="#type:byte">byte</a></td><td>signed 8-bit integer</td></tr>
<tr><td><a href="#type:double">double</a></td><td>64-bit IEEE 754 floating point</td></tr>
<tr><td><a href="#type:float">float</a></td><td>32-bit IEEE 754 floating point</td></tr>
<tr><td><a href="#type:int">int</a></td><td>signed 32-bit integer</td></tr>
<tr><td><a href="#type:long">long</a></td><td>signed 64-bit integer</td></tr>
<tr><td><a href="#type:map">map&lt;key-type,value-type&gt;</a></td><td>A map using the given types as keys and values. Keys and values can be any type.</td></tr>
<tr><td><a href="#type:position">position</a></td><td>Document position in geographical coordinates, e.g. latitude and longitude.</td></tr>
<tr><td><a href="#type:predicate">predicate</a></td><td>A boolean expression in predicate logic.</td></tr>
<tr><td><a href="#type:raw">raw</a></td><td>binary data</td></tr>
<tr><td><a href="#type:string">string</a></td><td>any text</td></tr>
<tr><td><a href="#type:struct">structname</a></td><td>Declares a field with a specific struct type, given by the struct name.</td></tr>
<tr><td><a href="#type:tag">tag</a></td><td>A weighted set of strings having regular tag semantics</td></tr>
<tr><td><a href="#type:tensor">tensor</a></td><td>A tensor with a set of named dimensions and a set of values located in the space of those dimensions.</td></tr>
<tr><td><a href="#type:uri">uri</a></td><td>A Uniform Resource Identifier (a URL or any other unique string id)</td></tr>
<tr><td><a href="#type:weightedset">weightedset&lt;element-type&gt;</a></td><td>A weighted set: Like an array, but each element is also assigned an integer <em>weight</em>.</td></tr>
</table>

<p>The body of a field is optional for <code><a href="#search">search</a></code>,
<code><a href="#document">document</a></code> and
<code><a href="#struct">struct</a></code>, and <strong>disallowed</strong> for
<code><a href="#annotation">annotation</a></code>. It may contain the following elements:</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#alias">alias</a></td>
<td>Make an index or attribute available in searches under an additional name</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#attribute">attribute</a></td>
<td>Specify an attribute setting.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#body_in_field">body</a></td>
<td>Makes this a body document field, not a header field. No value.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#bolding">bolding</a></td>
<td>Specifies whether content of this field should be bolded.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#header_in_field">header</a></td>
<td>Makes this a header document field, not a body field. No value.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#id">id</a></td>
<td>Explicitly decide the numerical id of this field. Is normally not necessary, but can be used to save some disk space.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#index">index</a></td>
<td>Specify a parameter of an index. <em>Not applicable to streaming search</em></td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#indexing">indexing</a></td>
<td>The indexing statements used to create index structure additions
from this field.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#indexing-rewrite">indexing-rewrite</a></td>
<td>Determines the rewriting Vespa is allowed to do on the indexing
statements of this field.<em>Not applicable to streaming search</em></td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#match">match</a></td>
<td>Set the matching type to use for this field.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#normalizing">normalizing</a></td>
<td>Specifies the kind of spelling normalizing to do on this field.</td>
<td>Zero or one.</td>
</tr>

<tr><td><a href="#query-command">query-command</a></td>
<td>Specifies a command which can be received by a plugin searcher in
the QRS.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#rank">rank</a></td>
<td>The high level ranking method to use for the field</td>
<td>Zero or one</td>
</tr>

<tr><td><a href="#rank-type">rank-type</a></td>
<td>Selects the set of low-level rank settings to be used for this field when using default <code>nativeRank</code>.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#sorting">sorting</a></td>
<td>The sort specification for this field.</td>
<td>Zero or one.</td>
</tr>

<tr><td><a href="#stemming">stemming</a></td>
<td>Specifies the kind of stemming to use for this field. <em>Not applicable to streaming search</em></td>
<td>Zero or one.</td>
</tr>

<tr><td><a href="#struct-field">struct-field</a></td>
<td>A subfield of a field of type struct. The struct must have been defined to
contain this subfield in the struct definition. If you want the subfield to
be handled differently from the rest of the struct, you may specify it within
the body of the struct-field.</td>
<td>Zero to many.</td>
</tr>

<tr><td><a href="#summary">summary</a></td>
<td>Sets a summary setting of this field, set to <code>dynamic</code>
to make a dynamic summary.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#summary-to">summary-to</a></td>
<td>The list of document summary names this should be included in. <em>Not applicable to streaming search, instead declare non-standard summaries in a document-summary tag outside of the document declaration</em></td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#weight">weight</a></td>
<td>The importance of a term boost field, a positive integer.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#weightedset">weightedset</a></td>
<td>Attributes of a weighted set type.</td>
<td>Zero to one</td>
</tr>

</table>

<p>If this field is part of a struct definition, i.e. contained in the
<code><a href="#struct">struct</a></code> element, only
<code><a href="#match">match</a></code> may be specified.</p>

<p>If this field is of type struct, only
<code><a href="#body_in_field">body</a></code>,
<code><a href="#header_in_field">header</a></code>,
<code><a href="#indexing">indexing</a></code>,
<code><a href="#match">match</a></code> and
<code><a href="#query-command">query-command</a></code> may be specified.</p>

<p class="note">A <code>field</code> declared outside of a <code>document</code> tag (i.e. immediately within
a <code>search</code> tag) is referred to as an <em>extra-field</em>. Such fields may not be set directly, not
programmatically and not through an xml feed -- doing so will cause the document to be rejected by the
indexer. Extra-field may only be populated using <a href="advanced-indexing-language.html">indexing statements</a> that
input the value of proper fields (e.g. <code>indexing: input my_document_field | normalize | summary |
index</code>).</p>

<h2 id="struct-field">struct-field</h2>
<p>Contained in <code><a href="#field">field</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>

<p>Defines how this struct field (a subfield of a struct) should be stored,
indexed, searched, presented and how it should influence ranking.
The field in which this struct field is contained must be of
type struct, which has defined this struct field.
Note that struct fields are only available for streaming search.
</p>

<pre>
field [name] {
    [body]
}
</pre>

<p>The body of a struct field is optional and may contain the following elements:</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#indexing">indexing</a></td>
<td>The indexing statements used to create index structure additions
from this field.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#match">match</a></td>
<td>Set the matching type to use for this field.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#query-command">query-command</a></td>
<td>Specifies a command which can be received by a plugin searcher in
the QRS.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#struct-field">struct-field</a></td>
<td>A subfield of a field of type struct. The struct must have been defined to
contain this subfield in the struct definition. If you want the subfield to
be handled differently from the rest of the struct, you may specify it within
the body of the struct-field.</td>
<td>Zero to many.</td>
</tr>

<tr><td><a href="#summary">summary</a></td>
<td>Sets a summary setting of this field, set to <code>dynamic</code>
to make a dynamic summary.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#summary-to">summary-to</a></td>
<td>The list of document summary names this should be included in.</td>
<td>Zero to one</td>
</tr>

</table>

<p>If this struct field is of type struct (i.e. a nested struct), only
<code><a href="#indexing">indexing</a></code>,
<code><a href="#match">match</a></code> and
<code><a href="#query-command">query-command</a></code> may be specified.</p>


<h2 id="header_in_document">header (in document)</h2>
<p>
Contained in <code><a href="#document">document</a></code>.
</p>

<p>
Configure options for the header part of the document.
</p>

<pre>
header {
    [body]
}
</pre>

<p>The body of a header specification is optional and may contain:</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#compression">compression</a></td>
<td>Specifies compression options for header fields in storage.</td>
<td>Zero to one</td>
</tr>

</table>


<h2 id="body_in_document">body (in document)</h2>
<p>
Contained in <code><a href="#document">document</a></code>.
</p>

<p>
Configure options for the body part of the document.
</p>

<pre>
body {
    [body]
}
</pre>

<p>The body of a body specification is optional and may contain:</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#compression">compression</a></td>
<td>Specifies compression options for body fields in storage.</td>
<td>Zero to one</td>
</tr>

</table>

<h2 id="fieldset">fieldset</h2>
<p>Contained in <code><a href="#search">search</a></code>.

<p><em>
Please note: this is not related to the <a href="fieldsets.html">fieldset syntax of vespaget</a>.
</a></em>

<p>
Field sets provide a way to group fields together for searching. When you query a field set,
you will get results from all the fields in the field set. Given the clause below:
</p>
<pre>
fieldset myfieldset {
  fields: a,b,c
}
</pre>
<p>
Using the query <code>yql=select+*+from+sources+*+where+myfieldset+contains+"foo"%3B</code> will return all the documents for which one or more of
the fields a, b or c contain "foo". By naming the field set 'default', you can search those fields without
specifying the field set in unstructured queries: <code>query=foo</code>.
</p>
<p>
The fields making up the field set should be as similar as possible in terms of indexing clause, matching etc.
If they are not, you must test your application thoroughly. For example, it will work for a mix of attributes
and indexes, but the matching for attribute fields will always be exact unless you are in streaming mode.
</p>
<p>
If you need specific match settings for the field set, such as exact, you must specify it using a
<a href="#match">match</a> clause:
</p>
<pre>
fieldset myfieldset {
  fields: a,b,c
  match {
    exact
  }
}
</pre>
<p>
You may use <code><a href="#query-command">query-commands</a></code> in the field set to set search settings.
Example:
</p>
<pre>
fieldset myfieldset {
  fields: a,b,c
  query-command:"exact @@"
}
</pre>
<h2 id="compression">compression</h2>
<p>
Contained in <code><a href="#document">document</a></code>,
<code><a href="#header_in_document">header</a></code> or
<code><a href="#body_in_document">body</a></code>.
</p>

<p>
If a compression level is given within this tag, <b>lz4</b> compression is enabled in storage for header fields, body fields or whole documents.
</p>

<pre>
compression {
    [body]
}
</pre>

<p>The body of a compression specification is optional and may contain:</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td id="type">type</a></td>
<td><b>LZ4</b> is the only valid compression method.</td>
<td>Zero to one</td>
</tr>

<tr><td id="level">level</a></td>
<td>Enable compression. LZ4 is linear and 9 means HC(high compression)</td>
<td>Zero to one</td>
</tr>

<tr><td id="threshold">threshold</a></td>
<td>A percentage (multiplied by 100) giving the maximum size that compressed data can have to keep the compressed value. If the resulting compressed data is higher than this, the document will be stored uncompressed. Default value is 95.</td>
<td>Zero to one</td>
</tr>

</table>


<h2 id="rank-profile">rank-profile</h2>
<p>Contained in <code><a
href="#search">search</a></code>.</p>

<p>A rank profile is a named set of rank settings which can be specified
during queries (see the <code>ranking</code> parameter in the
<a href="../reference/search-api.html">search API</a>).</p>

<p>Rank profiles are used to specify an alternative ranking of the same data for
different purposes, and to experiment with new rank settings.
If no explicit rank profile is specified, one called "default" is implicitly
created to hold the rank settings from each field. The "default" rank profile
is always selected for queries which does not specify one. It is possible to
add additional settings to the default rank profile by explicitly defining it.</p>

<pre>
rank-profile [name] inherits [rank-profile] {
    [body]
}
</pre>

<p>The <code>inherits</code> attribute is optional. If defined, it
contains the name of one other rank profile in the same search
definition. Values not defined in this rank profile will then be
inherited as expected. It is possible to inherit the default rank
profile, even if it is not explicitly listed.</p>

<p>In addition to the <code>default</code> rank profile, a profile named <code>unranked</code> is implicitly created.
This rank-profile makes sure that the rank phases in the search backend are skipped and
should be used for queries that only require matching and do not use ranking.
If you are sorting on something different than rank score this is also the profile to use.
Note that this profile should not be used if the query contains <code>Wand</code> search operators.
Also note that using this profile will give better performance as the rank phases are skipped.
</p>

<p>The body of a rank-profile may contain:</p>
<table>

<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#match-phase">match-phase</a></td>
<td>Ranking configuration to be used for hit limitation during matching.</td>
<td>Zero or one</td>
</tr>

<tr><td><a href="#firstphase-rank">first-phase</a></td>
<td>The ranking config to be used for first-phase ranking.</td>
<td>Zero or one</td>
</tr>

<tr><td><a href="#rankfeatures">rank-features</a></td>
<td>The <a href="../reference/rank-features.html">rank features</a> to be dumped when using the query-argument <code>rankfeatures</code>.</td>
<td>Zero or more</td>
</tr>
<tr><td><a href="#secondphase-rank">second-phase</a></td>
<td>The ranking config to be used for second-phase ranking.</td>
<td>Zero or one</td>
</tr>
<tr><td><a href="#summaryfeatures">summary-features</a></td>
<td>The <a href="../reference/rank-features.html">rank features</a> to be dumped for all queries.</td>
<td>Zero or more</td>
</tr>
<tr><td id="ignore-default-rank-features">ignore-default-rank-features</td>
<td>Do not dump the default set of rank features, only those explicitly specified with the <a href="#rankfeatures">rank-features</a> command.</td>
<td>Zero or one</td>
</tr>
<tr><td id="num-threads-per-search">num-threads-per-search</td>
<td>Overrides the global
<a href="../content/setup-proton-tuning.html#tuningrequestthreads">persearch</a> threads to a <b>lower</b> value.</td>
<td>Zero or one</td>
</tr>
<tr><td><a href="#constants">constants</a></td>
<td>List of constant key/value pairs available in ranking expressions.</td>
<td>Zero or one</td>
</tr>
<tr><td><a href="#rankproperties">rank-properties</a></td>
<td>List of any rank property key-values to be used by rank features.</td>
<td>Zero or one</td>
</tr>

<tr><td><a href="#macro-rank">macro [name] </a></td>
<td>A way to simply ranking expression by defining named macros that can be referenced during ranking phase(s) and as part of the summary-features.</td>
<td>Zero or more</td>
</tr>

<tr><td><a href="#rank">rank</a></td>
<td>The high level ranking method to use for a field in this profile.</td>
<td>Zero or more</td>
</tr>
<tr><td><a href="#rank-type">rank-type</a></td>
<td>The rank type of a field in this profile.</td>
<td>Zero or more</td>
</tr>
</table>

<p>Refer to the rank profiles defined in the example below.</p>

<h2 id="diversity">diversity</h2>
<p>Contained in <code><a href="#match-phase">match-phase</a></code>.</p>
<p>Diversity is used to specify diversity in different phases. Currently only supported in <code><a href="#match-phase">match-phase</a></code>.</p>
<p>It is used to guarantee a minimum diversity produced by the phase.</p>
<p>You specify the name of an attribute that will be used to provide diversity. Then you are guaranteed to get
at least <code><a href="#diversity-min-groups">min-groups</a></code> unique values from the <code><a href="#diversity-min-groups">diversity attribute</a></code>
from this phase.</p>
<p> We will only consider a document as a candidate if:<p>
<ul>
<li>You have not yet reached the <code><a href="#match-phase-max-hits">max-hits</a></code> number produced from this phase.</li>
<li>You have not yet reached the max number of candidates in one group. This is computed by the <code><a href="#match-phase-max-hits">max-hits</a></code> of the phase
    divided by <code><a href="#diversity-min-groups">min-groups</a></code></li>
</ul>

<pre>
diversity {
    attribute: [numeric attribute]
    min-groups: [integer]
}
</pre>
<p>The body of a diversity statement consists of:</p>

<table>
<tr><th>Name</th><th>Description</th></tr>

<tr><td id="diversity-attribute">attribute</td>
<td>Which attribute to use when deciding diversity. The attribute referenced must be a single valued numeric or string attribute.</td>
</tr>

<tr><td id="diversity-min-groups">min-groups</td>
<td>Specifies the minimum number of groups you want returned from the phase. Using this with <code><a href="#match-phase">match-phase</a></code>
often mean that you can reduce <code><a href="#match-phase-max-hits">max-hits</a></code></td>
</tr>

</table>

<h2 id="match-phase">match-phase</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>
<p>The config specifying ranking to be used during matching.  This is
used to limit the result set to a manageable size if it is discovered
to be too large; it is especially useful if the first-phase ranking is
expensive.  It may also be used for sorting on numeric values to limit
the actually returned hits to a manageable size.
<pre>
match-phase {
    attribute: [numeric single value attribute]
    order: [ascending | descending]
    max-hits: [integer]
    <code><a href="#diversity">diversity</a></code>
}
</pre>

<p>The body of a match-phase statement consists of:</p>

<table>
<tr><th>Name</th><th>Description</th></tr>

<tr><td id="match-phase-attribute">attribute</td>
<td>Which attribute to use as the quality signal. The attribute referenced must be a single valued numeric attribute with the <a href="#attribute">attribute option</a> <i>fast-search</i> enabled. No default.</td>
</tr>

<tr><td id="match-phase-order">order</td>
<td>Whether the attribute should be used in <code>descending</code> order (prefer documents with a high score) or <code>ascending</code> order (prefer documents with a low value in the attribute).  Usually it is not necessary to specify this, as the default value <code>descending</code> is by far the most common.</td>
</tr>

<tr><td id="match-phase-max-hits">max-hits</td>
<td>How many hits we would like to get (per search node).  Usually a number like 10000
works well here, but there is no default for this - you must consider your use cases and
specify a number that works for you.</td>
</tr>

</table>

<p>
This works by specifying an <code>attribute</code> that measures document
quality in some way (popularity, click-through rate, pagerank, bid value,
price, text quality).  In addition a <code>max-hits</code> value is specified
that specifies how many hits are "more than enough" for your application.
Then an estimate is made after collecting a reasonable amount of
hits for the query, and if the estimate is higher than the configured
<code>max-hits</code> value, an extra limitation is added to the query,
ensuring that only the highest quality documents can become hits.
<p>
In effect this limits the documents actually searched to the highest
quality documents, a subset of the full corpus, where the
size of subset is calculated in such a way that the query is
estimated to give <code>max-hits</code> hits.  Since some (low-quality)
hits will already have been collected to do the estimation, the
actual number of hits returned will usually be higher than max-hits.
But since the distribution of documents isn't perfectly smooth,
you risk sometimes getting less than the configured
<code>max-hits</code> hits back.
<p>
Note that limiting hits in the match-phase also affects aggregation,
grouping, and total-hit-count since it actually limits so the query
gets less hits.  Also note that it doesn't really make sense to use this
feature together with a WAND operator that also limit your hits, since they
both operate in the same manner and you would get interference between
them that could cause very unpredictable results.
<p>
<img src="match-phase-max-hits.png">
<p>
The graph above shows possible
hits versus actual hits in a corpus with 100 000 documents, where
<code>max-hits</code> is configured to 10 000.  The corpus here
used is a synthetic (slightly randomized) data set,
so in practice the graph won't be as smooth as this.
<p>
There is a searchnode metric per rank-profile named "limitedqueries"
to see how many of your queries are actually affected by these settings;
compare with the corresponding "queries" metric to measure the percentage.

<h2 id="firstphase-rank">first-phase</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>The config specifying the first phase of ranking. This is the initial ranking performed on all hits, and you should therefore avoid doing heavy rank-calculations here. By default, this will use the ranking feature <code>nativeRank</code>.
</p>
<pre>
first-phase {
    [body]
}
</pre>

<p>The body of a firstphase-ranking statement consists of:</p>

<table>
<tr><th>Name</th><th>Description</th></tr>

<tr><td><a href="#rankfeatures-expression">expression</a></td>
<td>Specify the ranking expression to be used for first phase of ranking. (for a description,
    see the <a href="../reference/ranking-expressions.html">ranking expression</a> documentation.</td>
</tr>

<tr><td id="keep-rank-count">keep-rank-count</td>
<td>How many documents to keep the first phase top rank values for. Default value is 10000.</td>
</tr>

<tr><td id="rank-score-drop-limit">rank-score-drop-limit</td>
<td>Drop all hits with a first phase rank score less than or equal to this floating point number.
Default value is -Double.MAX_VALUE.
</tr>

</table>

<h2 id="rankfeatures-expression">expression</h2>
<p>Contained in <code><a
href="#firstphase-rank">first-phase</a></code> or <code><a href="#secondphase-rank">second-phase</a></code>.</p>
<p>
Specify a <a href="../reference/ranking-expressions.html">ranking expression</a>. The expression can either be written directly or loaded from a file. When writing it directly the syntax is:</p>
<pre>
expression: [ranking expression]
</pre>
or
<pre>
expression {
    [ranking expression]
    [ranking expression]
    [ranking expression]
    &hellip;
}
</pre>
<p>
The second format is primarily a convenience feature when using long expressions, enabling them
to be split over multiple lines.</p>

<p>
Expressions can also be loaded from a separate file. This is useful when dealing with the very long
expressions genereated by e.g. MLR. The syntax is:</p>
<pre>
expression: file:[path-to-expressionfile]
</pre>
<p>
The path is relative to the location of the search definition file
(note: directories are not allowed in the path).
The file itself must end with <code>.expression</code>. This suffix
is optional in the sd-file. Therefore
<code>expression: file:mlrranking.expression</code> and
<code>expression: file:mlrranking</code> are identical. Both refer to a
file called <code>mlrranking.expression</code> in the
searchdefinition directory.
</p>


<h2 id="rankfeatures">rank-features</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>List of extra <a href="../reference/rank-features.html">rank features</a> to be dumped when using the query-argument <code>rankfeatures</code>.</p>
<pre>
    rank-features: [feature] [feature]&hellip;
</pre>
or
<pre>
rank-features {
    [feature]
    [feature]
}
</pre>

<p>Any number of ranking features can be listed on each line, separated by space</p>

<h2 id="constants">constants</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>List of constants available in ranking expressions, resolved and optimized at configuration time.</p>
<pre>
constants {
    key: value
}
</pre>

<table>
<tr><th>Name</th><th>Description</th></tr>
<tr><td>key</td>
<td>Name of the constants.
</tr>
<tr><td>value</td>
<td>A number or any string. Must be quoted if it contains spacing.</td>
</tr>
</table>

<h2 id="rankproperties">rank-properties</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>List of generic properties, in the form of key/value pairs to be used by ranking features.</p>
</p>
<pre>
rank-properties {
    key: value
}
</pre>

<table>
<tr><th>Name</th><th>Description</th></tr>
<tr><td>key</td>
<td>Name of the property.
</tr>
<tr><td>value</td>
<td>A number or any string. Must be quoted if it contains spacing.</td>
</tr>
</table>

<h2 id="macro-rank">macro (inline)? [name]</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>
<p>it is possible to define named expression macros that can be referenced as a part of the ranking expression. A macro accepts any number of arguments.</p>
<pre>
macro [name]([arg1], [arg2], &hellip;) {
  expression: &hellip;
}
</pre>
or
<pre>
macro [name] ([arg1], [arg2], &hellip;) {
  expression {
      [ranking expression]
      [ranking expression]
      &hellip;
}
</pre>

<p>Note that the parenthesis is required after the name.</p>
<p>A rank-profile example is shown below:</p>
<pre>
rank-profile default inherits default {
  macro myfeature() {
    expression: fieldMatch(title) + freshness(timestamp)
  }
  macro otherfeature(foo) {
    expression{ nativeRank(foo, body) }
  }

  first-phase {
    expression: myfeature * 10
  }
  second-phase {
    expression: otherfeature(title) * myfeature
  }
  summary-features: myfeature
}
</pre>
<p>You can not include macros that accept arguments in summary features.</p>

<p>Adding the <code>inline</code> modifier will inline this macro in the calling expression if it
also has no arguments. This is faster for very small and cheap macros (and more expensive for others).</p>

<h2 id="secondphase-rank">second-phase</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>The config specifying the second phase of ranking. This is the optional reranking performed on the best hits from the
first phase, and where you should put any advanced ranking calculations (e.g. MLR). By default, no second-phase ranking is
performed. <em>In streaming search we perform the second phase ranking on all hits.
You can therefore put all the rank calculation in the first phase rank expression and just skip second phase.</em>
</p>
<pre>
second-phase {
    [body]
}
</pre>

<p>The body of a secondphase-ranking statement consists of:</p>

<table>
<tr><th>Name</th><th>Description</th></tr>
<tr><td><a href="#rankfeatures-expression">expression</a></td>
<td>Specify the ranking expression to be used for first phase of ranking. (for a description,
    see the <a href="../reference/ranking-expressions.html">ranking expression</a> documentation.</td>
</tr>
<tr><td id="rerank-count">rerank-count</td>
<td>Optional argument. Specifies the number of hits to be reranked. Default value is 100</td>
</table>


<h2 id="summaryfeatures">summary-features</h2>
<p>Contained in <code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>List of <a href="../reference/rank-features.html">rank
features</a> to be dumped for every query. Using many items will have a
performance impact, a larger list to be returned only when requested can
be specified in <a href="#rankfeatures">ranking features</a>.
</p>
<pre>
    summary-features: [feature] [feature]&hellip;
</pre>
<p>
or
</p>
<pre>
summary-features {
    [feature]
    [feature]
}
</pre>

<p>Any number of ranking features can be listed on each line, separated by space</p>


<h2 id="document-summary">document-summary</h2>
<p>Contained in <code><a href="#search">search</a></code>.</p>

<p>
An explicitly defined document summary.  By default, a document summary
named <code>default</code> is created.  Using this element, other document
summaries containing a different set of fields can be created.
</p>
<pre>
document-summary [name] {
    [body]
}
</pre>

<p>The body of a document summary consists of</p>

<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#summary">summary</a></td>
<td>A summary field in this document summary.</td>
<td>Zero to many</td>
</tr>
</table>

<p>Use the <code>summary</code> query parameter to choose a document
summary in searches. See also <a
href="../multiple-summaries.html">multiple summaries</a> for more
details and examples.</p>

<h2 id="stemming">stemming</h2>
<p>Contained in <code><a href="#field">field</a></code>,
<code><a href="#search">search</a></code> or
<code><a href="#index">index</a></code>.</p>

<p>Sets how to stem a field or an index,
or how to stem by default. Stemming means to translate a word
to its base form. This increases recall when searching, because the
searcher is usually interested in documents containing query words
regardless of the word form used. Stemming in Vespa is
<em>symmetric</em>, words are converted to stems both when indexing and
searching. <em>Not applicable to streaming search</em>.</p>
<pre>
stemming: [stemming-type]
</pre>

<p>The stemming types are</p>
<table>
<tr><th>Type</th><th>Description</th></tr>
<tr><td><code>none</code></td><td>No stemming</td></tr>
<tr><td><code>shortest</code></td><td>Stem all words to their shortest form.</td></tr>
<tr><td><code>all</code></td><td>Same as "shortest", for historical reasons. Stem all words to their shortest form.</td></tr>
<tr><td><code>multiple</code></td><td>Use multiple stems. Retains all stems returned from the linguistics library.</td></tr>
</table>

<p>If a stemming setting is not given on the search definition level,
<code>shortest</code> is used as the default setting. Fields gets the
default setting unless they define their own stemming setting.
See also <a href="../stemming.html">Stemming</a>.
</p>



<h2 id="normalizing">normalizing</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Sets the
normalizing to be done on this field. Normalizing will cause accents
and similar decorations which are often misspelled to be normalized
the same way both in documents and queries. <em>Not applicable to streaming search</em></p>
<pre>
normalizing: [normalizing-type]
</pre>

<p>The normalizing type available is</p>
<table>
<tr><th>Type</th><th>Description</th></tr>
<tr><td><code>none</code></td><td>No normalizing</td></tr>
</table>

<p>If this is not set, normalization will be done for this field.</p>

<h2 id="alias">alias</h2>
<p>Contained in <code><a href="#attribute">attribute</a></code>,
<code><a href="#field">field</a></code> or
<code><a href="#index">index</a></code>.</p>

<p>Makes an index or attribute available under an additional name.</p>

<pre>
alias [index/attr-name]: [alias]
</pre>

<p>If the index/attribute name is skipped, the containing field or index name is
used. Alias names can be any name string, dots are allowed as well.</p>




<h2 id="attribute">attribute</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Specifies a property of an index structure attribute.</em></p>

<pre>
attribute [attribute-name]: [property]
</pre>
or
<pre>
attribute [attribute-name] {
    [property]
    [property]
    &hellip;
}
</pre>


<p>The attribute name can be skipped, in which case the field name is
used. The following properties are available:</p>

<table>
<tr><th>Property</th><th>Description</th></tr>
<tr><td>fast-search</td><td>At the cost of memory you will get faster search when there are few hits and you have no other limiting factors.</td></tr>
<tr><td>fast-access</td><td>
In an indexed content cluster with
<a href="../content/setup-reference.html#searchable-copies"><code>searchable-copies</code></a> &lt;
<a href="../content/setup-reference.html#redundancy"><code>redundancy</code></a>
this property can be set to make sure that this attribute is always kept in memory for fast access in
the context of applying partial updates and when used in a
<a href="../content/setup-reference.html#documents">selection expression</a> for garbage collection.
If <code>redundancy</code> == <code>searchable-copies</code> (default) this property is a no-op.
</td></tr>
<tr><td>huge</td><td>You should use this on your multi-value attributes if you have more than 128M documents per node, or you have many documents with more than 14 values for this attribute.
The cost is an additional 4 bytes per document, but the loss is more than compensated by better memory management.</td></tr>
<tr><td><a href="#alias">alias</a></td><td>An alias for the attribute. Add an attribute name before the colon to specify an alias for another attribute
than the one given by field name.</td>
<tr><td><a href="#sorting">sorting</a></td><td>The sort specification for this attribute.</td></tr>
<tr><td><a href="#tensor-type-spec">[tensor-type-spec]</a></td><td>The tensor type specification for this tensor attribute.</td></tr>
</table>

<p>
An attribute will also become multi-valued if you assign it multiple
values during indexing, either by using e.g. split and for_each
or by letting multiple fields write their value to the attribute
field.
</p>



<h2 id="sorting">sorting</h2>
<p>
Contained in <code><a href="#attribute">attribute</a></code> or
<code><a href="#field">field</a></code>.
</p>

<p>
Specifies how sorting should be done.
</p>

<pre>
sorting : [property]
</pre>
or
<pre>
sorting {
    [property]
    [property]
    &hellip;
}
</pre>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>order</td>
      <td>
        Either <em>ascending</em> or <em>descending</em>. Default is
        ascending. Used unless overridden
        in <a href="../reference/sorting-syntax.html">sortspec</a>
        in query.
      </td>
    </tr>
    <tr>
      <td>function</td>
      <td>
        The <a href="../reference/sorting-syntax.html#sort-function">Sort
        function</a> to be used.  Implemented functions
        are <em>raw</em>, <em>lowercase</em>, and <em>uca</em>. The
        default
        is <a href="../reference/sorting-syntax.html#uca"><em>uca</em></a>,
        but please note that if no language or locale is specified in
        the query sortspec, the field, or generally for the
        query, <a href="../reference/sorting-syntax.html#lowercase">lowercase</a>
        will be used instead. Used unless overridden
        in <a href="../reference/sorting-syntax.html">sortspec</a>
        in query.
      </td>
    </tr>
    <tr>
      <td>strength</td>
      <td>
        <a href="../reference/sorting-syntax.html#uca">Sort
        strength</a> to be used. Implemented levels are <em>primary</em>,
        <em>secondary</em>, <em>tertiary</em>, <em>quaternary</em>
        and <em>identical</em>. The default
        is <em>primary</em></a>. Used unless overridden
        in <a href="../reference/sorting-syntax.html">sortspec</a>
        in query.  Only applicable if <code>function</code> is set
        to <em>uca</em>.
      </td>
    </tr>
    <tr>
      <td>locale</td>
      <td>
        <a href="../reference/sorting-syntax.html#uca">Locale</a>
        to be used. The default is none, indicating that it is
        inferred from query. It should only be set here if the
        attribute is filled with data that is in 1 language only. Used
        unless overridden
        in <a href="../reference/sorting-syntax.html">sortspec</a>
        in query. Only applicable if <code>function</code> is set
        to <em>uca</em>.
      </td>
    </tr>
  </tbody>
</table>


<h2 id="tensor-type-spec">tensor-type-spec</h2>
<p>
Contained in <code><a href="#attribute">attribute</a></code>.
</p>

<p>
Specifies the tensor type for a tensor.
</p>

<p>
A tensor type contains a list of dimensions on the format:
<pre>
tensor(dimension1,dimension2,...,dimensionN)
</pre>

A dimension is specified as follows:
<ul>
  <li><code>dimension-name{}</code> - a mapped dimension.
  <li><code>dimension-name[size]</code> - a bound indexed dimension with the given size.
  <li><code>dimension-name[]</code> - an unbound indexed dimension.
</ul>

We only support tensor types with either only mapped dimensions or
only bound indexed dimensions.
</p>

<p>
The tensor type for a tensor with two mapped dimensions <em>x</em> and <em>y</em> looks like this:
<pre>
tensor(x{},y{})
</pre>

Example tensor with this type:
<pre>
{{x:a,y:b}:10,{x:c,y:d}:20}
</pre>
</p>

<p>
The tensor type for a tensor with two bound indexed dimensions <em>x</em> and <em>y</em> with sizes 3 and 2 respectively looks like this:
<pre>
tensor(x[3],y[2])
</pre>

Example tensor with this type (representing a matrix):
<pre>
{{x:0,y:0}:1,{x:0,y:1}:2,
 {x:1,y:0}:3,{x:1,y:1}:5,
 {x:2,y:0}:7,{x:2,y:1}:11}
</pre>

Note that the labels are indexes in the range <em>[0,dimension-size&gt;</em>
</p>



<h2 id="body_in_field">body (in field)</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Makes the field a body field, instead of a
<a href="#header_in_field">header</a> field.
</p>
<pre>
body
</pre>
<p>Fields potentially containing large amounts of data should be made
body fields to ensure efficient storage operation. Body fields cannot
be used for selection by subscribers or visitors, but is otherwise
equal to header fields, i.e. they can be indexed and so on.</p>



<h2 id="bolding">bolding</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Highlight matching query terms in the summary.</p>
<pre>
bolding: on
</pre>
<p>
    Not applicable to streaming search. Instead use <code>summary: dynamic</code>.
<p>
    The default is no bolding, set <code>bolding: on</code> to turn bolding on. Note that this command is overridden by
    <code>summary: dynamic</code>, if both are specified, this will be ignored. The difference of using bolding instead
    of <code>summary: dynamic</code> is that the latter will provide a dynamic abstract in addition to highlighting
    search terms while the first only does highlighting. The default XML tag used to highlight the search terms is &lt;hi&gt;.
</p>

<p>
    The XML tags used to highlight search terms in the result template can be configured by overriding the
    container.qr-searchers configuration in <a href="services-search.html#sec-1">services.xml</a>. E.g. using &lt;b&gt;:

<pre class="brush: xml">
&lt;jdisc&gt;
  &lt;search&gt;
    &lt;config name="container.qr-searchers"&gt;
      &lt;tag&gt;
        &lt;bold&gt;
          &lt;open&gt;&amp;lt;b&amp;gt;&lt;/open&gt;
          &lt;close&gt;&amp;lt;/b&amp;gt;&lt;/close&gt;
        &lt;/bold&gt;
      &lt;/tag&gt;
    &lt;/config&gt;
  &lt;search&gt;
&lt;jdisc&gt;
</pre>
</p>

<h2 id="header_in_field">header (in field)</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Makes the
field a header field, instead of a <a href="#body_in_field">body</a> field.
</p>
<pre>
header
</pre>
<p>Refer to the descripton of <a href="#body_in_field">body</a>. Make sure that
fields you will use when visiting are header fields. Once a document is
stored, one cannot change the header/body setting for a field.</p>


<h2 id="id">id</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Explicitly
decides the numerical id of this field. All fields have a
document-internal id
internally for transfer and storage. Id's are usually determined
programmatically as a 31-bit number. Some storage and transfer space
can be saved by instead explicitly setting id's to a 7-bit number.</p>
<pre>
id: [positive integer]
</pre>

<p>An id must satisfy this requirements:</p>
<ul>
<li>Must be a positive integer</li>
<li>Must be less than 100 or larger than 127</li>
<li>Must be unique within the document and all documents this document inherits</li>
</ul>


<h2 id="index">index</h2>
<p>Contained in <code><a
href="#field">field</a></code> or <code><a
href="#search">search</a></code>.</p>

<p>Sets index parameters. This element
can be single- or multi-valued.</p>
<pre>
index [index-name]: [property]
</pre>
or
<pre>
index [index-name] {
    [property]
    [property]
    &hellip;
}
</pre>

<p>The index name can be skipped inside fields, causing the index name
to be the field name. Possible field parameters are:</p>

<table>
<tr><th>Property</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><a href="#alias">alias</a></td>
<td>Specify an alias to this index to be available in searches.</td>
<td>Zero to many</td>
</tr>

<tr><td><a href="#stemming">stemming</a></td>
<td>Set the stemming of this index.
Indexes without a stemming setting get their stemming setting from
the fields added to the index. Setting this explicitly is useful if
fields with conflicting stemming settings are added to
this index.</td>
<td>Zero to one</td>
</tr>

<tr><td><a href="#arity">arity</a></td>
<td>Set the arity value for boolean search. See
<a href="../boolean-search.html#index_size">Using Boolean Search with Vespa</a>. The data
type for the containing field must be <code>predicate</code>.</td>
<td>One (mandatory for boolean search), else zero.</td>
</tr>

<tr><td><a href="#lower-bound">lower-bound</a></td>
<td>Set the lower bound value for boolean search. See
<a href="../boolean-search.html#upper_lower_bound">
Using Boolean Search with Vespa</a>. The data
type for the containing field must be <code>predicate</code>.</td>
<td>Zero to one.</td>
</tr>

<tr><td><a href="#upper-bound">upper-bound</a></td>
<td>Set the upper bound value for boolean search. See
<a href="../boolean-search.html#upper_lower_bound">
Using Boolean Search with Vespa</a>. The data
type for the containing field must be <code>predicate</code>.</td>
<td>Zero to one.</td>
</tr>

<tr><td><a href="#dense-posting-list-threshold">dense-posting-list-threshold</a></td>
<td>Set the dense posting list threshold value for boolean search. See
<a href="../boolean-search.html#dense_posting_list_threshold">
Using Boolean Search with Vespa</a>. The data
type for the containing field must be <code>predicate</code>.</td>
<td>Zero to one.</td>
</tr>

</table>





<h2 id="indexing">indexing</h2>
<p>Contained in <code><a href="#field">field</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>
<p>One or more Indexing Language instructions used to produce index, attribute
and summary data from this field. Indexing instructions has pipeline
semantics similar to unix shell commands. The value of the field
enters the pipeline during indexing and the pipeline puts the value
into the desired index structures, possibly doing transformations and
pulling in other values along the way.</p>

<pre>
indexing: [index-statement]
</pre>
or
<pre>
indexing {
    [indexing-statement];
    [indexing-statement];
    &hellip;
}
</pre>

<p>See <a href="../indexing-language.html">the indexing language
reference</a> for details on legal indexing statements.</p>

<p>If the field containing this is defined outside the document, it
must start by an indexing statement which
outputs a value (either "field [fieldname]" to fetch a field value,
or a literal). Fields in documents will use the value of the enclosing
field as input (field [fieldname]) if one isn't explicitly provided.</p>




<h2 id="indexing-rewrite">indexing-rewrite</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>Vespa will normally rewrite indexing statements extensively to
implement the technical tasks which are required to carry out the
intentions of the indexing statement. The rewriting done can be
controlled using this element.</p>

<pre>
indexing-rewrite: none
</pre>

<p>Include this to let an indexing statement pass through
unaltered. Note that such statements must begin with an
<code>input &lt;fieldname&gt;</code>, <code>get_var</code> or
constant expression. You should understand which rewrites Vespa
does, and be certain that your indexing statement can do without them
to use this. This statement must be placed somewhere below the
<code>indexing</code> statement in the field.</p>


<h2 id="match">match</h2>
<p>Contained in <code><a href="#field">field</a></code>, <code><a href="#fieldset">fieldset</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>

<p>Sets the matching method to use for this field to something else
than the default token matching. Please take note of the restrictions
found in the column named &quot;Legal with&quot; in the table
below.</p>

<pre>
match: [property]
</pre>

<p>
or
</p>

<pre>
match {
    [property]
    [property]
    &hellip;
}
</pre>

<p>
Whether the match type is <code>text</code>, <code>word</code> or
<code>exact</code>, all term matching will be done after NFKC normalization and
locale independent lowercasing (in that order).
</p>

<table>
<tr><th>Property</th><th>Description</th><th>Legal with</th><th>Remarks</th></tr>

<tr><td><code>text</code></td>
<td>This field is matched per token. Tokens are created by splitting on whitespace and non-letter characters, as
well as by segmentation for CJK. All characters which are not letters or digits are ignored using text matching.
Previously also known as "token" matching.
</td>
<td>Indexes, streaming</td>
<td>Default for indexes. Can not be combined with exact matching.</td>
</tr>

<tr><td><code>word</code></td>
<td><p>A single word is formed from the field input (or each item in the field input
if it is an array or a weighted set).  This word is matched <em>exactly</em>:
Strings containing any characters whatsoever will be indexed and matched as-is.
In queries, the word to match is heuristically parsed taking into account some
usual query syntax characters; one can also use double quotes to include space,
star, or exclamation marks.  This is the default matching mode for string
attributes.</p>

<p>Example: If <code>artist</code> is a string attribute, this
(advanced syntax) query:
<pre>
foo AND (artist:"'N Sync" OR artist:"*NSYNC" OR artist:A*teens OR artist:"Wham!")
</pre>
will match documents containing <code>foo</code> and at least one of
<code>'N Sync</code> or <code>*NSYNC</code> or <code>A*teens</code> or <code>Wham!</code>
as the artist field.</p>

<p>Note that without the quotes, the space in <code>'N Sync</code> would end that word
and would result in a search for just <code>'N</code>, similarly the <code>!</code> would mean to
increase the weight of a <code>Wham</code> term if not quoted.
</p>
</td>
<td>Indexes, attributes</td>
<td>Default for attributes. Can not be combined with text (token) matching.</td>
</tr>


<tr id="exact"><td><code>exact</code></td>
<td><p>This field is matched <em>exactly</em>: Strings containing any characters whatsoever will be
indexed and matched as-is. In queries, the exact match string ends at
the exact match terminator, which is <code>@@</code> per default.
As a side effect, a field with <code>match: exact</code> is considered to be
a <a href="#filter">filter field</a>, just as if <code>rank: filter</code> was specified.

This is because you will only get one word per field (or per item in the
case of multi-valued types such as <code>array&lt;string&gt;</code>),
so there isn't much ranking information that you could get anyway.
You can turn off the implicit <code>rank: filter</code> by adding an
explicit <code>rank: normal</code>.
</p>

<p>Example: If <code>tag</code> is an exact match field, this
(advanced syntax) query:
<pre>
someword AND (tag:!*!@@ OR tag:(kanoo)@@)
</pre>
will match documents containing <code>someword</code>
and either <code>!*!</code> or <code>(kanoo)</code> as a tag.</p>

<p>Note that without the <code>@@</code> terminating the
second tag string, the second tag value would be <code>(kanoo))</code>.</p>
</td>
<td>Indexes, attributes, streaming</td>
<td>Can not be combined with text (token) matching.</td>
</tr>

<tr><td><code>exact-terminator</code></td>
<td><p>
When using exact match, a terminator for use in queries should be
specified.
The default is <code>@@</code>, but if the strings to match can contain two
at-signs in a row, a different terminator must be used.  Alternately
the "word match" feature can be used, see above.
</p>

<p>Example
<pre>
    match {
        exact
	exact-terminator: "@@"
    }
</pre>
on the <code>tag</code> field will cause the query <code>tag:a b c!@@</code>
to match documents containing the exact string <code>a b c!</code></p>
</td>
<td>Indexes, attributes, streaming</td>
<td>Only legal if exact matching is chosen.</td>
</tr>

<tr><td><code>prefix</code></td>
<td>This field supports prefix* searches. For streaming: this field uses prefix* searching for all search terms.</td>
<td>Attributes, streaming</td>
<td>Prefix searching is always enabled for attributes and in streaming.
In these cases use the query syntax for prefix terms to get prefix searching even though the match method is not prefix.</td>
</tr>

<tr><td><code>substring</code></td>
<td>This field uses *substring* searching for all search terms as default.</td>
<td>Streaming</td>
<td>Substring searching is always enabled in streaming.
Use the query syntax for substring terms to get substring searching even though the match method is not substring.</td>
</tr>

<tr><td><code>suffix</code></td>
<td>This field uses *suffix searching for all search terms as default.</td>
<td>Streaming</td>
<td>Suffix searching is always enabled in streaming.
Use the query syntax for suffix terms to get suffix searching even though the match method is not suffix.</td>
</tr>

<tr><td><code>gram</code></td>
<td>This field is matched using n-grams. For example, with the default gram size 2 the string "hi blue" is tokenized to "hi bl lu ue" both in the index and in queries to the index.
	<p>
		N-gram matching is useful mainly as an alternative to segmentation in CJK languages. Typically it results in increased recall and lower precision. However, as
Vespa usually uses proximity in ranking the precision offset may not be of much importance. Grams consumes more resources than other matching methods because both
indexes and queries will have more terms, and the terms contains repetition of the same letters. On the other hand, CPU intensive CJK segmentation is avoided.
<p>
It may also be used for substring matching in general.</td>
<td>Indexes</td>
<td></td>
</tr>

<tr><td><code>gram-size</code></td>
<td>Sets the gram size when gram matching is used. The default size (if this is not present) is 2.
<p>Example
<pre>
    match {
        gram
        gram-size: 3
    }
</pre>
<td>Indexes
<td>This may be any positive number larger than 0.
</tr>

</table>

<h2 id="rank">rank</h2>
<p>Contained in <code><a href="#field">field</a></code> or
<code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>Set the kind of ranking calculations which will be done for the field. Even though the
actual ranking expressions decide the ranking, this settings tells Vespa which preparatory calculations
and which data structures are needed for the field.

<pre>
rank [field-name]: [ranking settings]
</pre>

<p>
or
</p>

<pre>
rank {
    [ranking setting]
}
</pre>

<p>The field name should only be specified when used inside a rank-profile.</p>

<p>
The following ranking settings are supported in addition to the default:
<table>
<tr><th>Ranking setting</th><th>Description</th></tr>
<tr><td id="filter"><code>filter</code></td><td>
Indicates that matching in this field should use fast bit vector data
structures only. This saves a lot of CPU during matching, but only a few
simple ranking features will be available for the field. This setting
is appropriate for fields typically used for filtering or simple boosting
purposes, like filtering or boosting on the language of the document.
</td></tr>
<tr><td id="normal"><code>normal</code></td><td>
The reverse of "filter", indicates that matching in this field should use
normal data structures and give normal match information for ranking.
Used to turn off implict <code>rank: filter</code> when using
<a href="#exact">match: exact</a>.  If both "filter" and "normal" are set
somehow, the effect is as if only "normal" was specified.
</td></tr>
</table>


<h2 id="query-command">query-command</h2>
<p>Contained in <code><a href="#fieldset">fieldset</a></code>, <code><a href="#field">field</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>

<p>Specifies a function to be performed on query terms to the indexes
of this field when searching. The QR server has support for writing
Vespa Searcher plugins which processes these commands.</p>
<pre>
query-command: [any string]
</pre>

<p>If you write a plugin searcher which needs some index-specific
configuration parameter, that parameter can be set here.</p>




<h2 id="rank-type">rank-type</h2>
<p>Contained in <code><a
href="#field">field</a></code> or
<code><a href="#rank-profile">rank-profile</a></code>.</p>

<p>
Selects the low-level rank settings to be used for this field when using <code>nativeRank</code>.
</p>
<pre>
rank-type [field-name]: [rank-type-name]
</pre>

<p>The field name can be skipped inside fields.</p>

<p>Defined rank types are:</p>
  <table>
    <tr><th>Type</th><th>Description</th></tr>
    <tr>
      <td>identity</td>
      <td>
        Used for fields which contains only what this document
        <em>is</em>, e.g. "Title". Complete identity hits will get a
        very high rank.
      </td>
    </tr>
    <tr>
      <td>about</td>
      <td>
        Some text which is (only) about this document,
        e.g. "Description". About hits get high rank on partial
        matches and higher for matches early in the text and
        repetitive matches.
        This is the default rank type.
      </td>
    </tr>
    <tr>
      <td>tags</td>
      <td>
        Used for simple tag fields of type tag. The tags rank type uses a logarithmic table to give more relative boost in the low range: As tags are added they should have significant impact on rank score, but as more and more tags are added, each new tag should contribute less.
      </td>
    </tr>
    <tr>
      <td>empty</td>
      <td>
        Gives no relevancy effect on matches. Used for fields you just
        want to treat as filters.
      </td>
    </tr>
  </table>

<p>
For <code>nativeRank</code> you can specify a rank type per field.
If the supported rank types do not meet your requirements you can explicit configure
the native rank features using rank-properties.
See the <a href="../reference/nativerank.html">native rank reference</a> for more information.
</p>


<h2 id="summary-to">summary-to</h2>
<p>Contained in <code><a href="#field">field</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>
<p>Specifies the
name of the document summaries which should contain this field. </p>
<pre>
summary-to: [summary-name], [summary-name], &hellip;
</pre>
<p>
If this is not specified, the field or struct-field will be included in the default document
summary. See also <a
href="../multiple-summaries.html">multiple summaries</a> for more
details and examples.
</p>




<h2 id="summary">summary</h2>
<p>Contained in <code><a href="#field">field</a></code> or
<code><a href="#document-summary">document-summary</a></code> or
<code><a href="#struct-field">struct-field</a></code>.</p>

<p>Declares a summary field.</p>
<pre>
summary: [property]
</pre>
<p>or</p>
<pre>
summary [name] type <a href="#field_types">[type]</a> {
    [body]
}
</pre>

<p>The summary <em>name</em> can be skipped if this is set inside a
field. The name will then be the same as the name of the source
field. In fields, the summary <em>type</em> can also be skipped, in
which case the type will be determined by the field type.
The summary data types available are the same as the document field
data types.
The body of a summary may contain:</p>
<table>
<tr><th>Name</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><code><a href="#full">full</a></code></td>
<td>Returns the full field value in the summary (the default).</td>
<td>Zero to one</td>
</tr>

<tr><td><code><a href="#dynamic">dynamic</a></code></td>
<td>Make this a dynamic abstract by extracting sentence
fragments around matches, and highlighting matched query-terms. This
highlighting is not affected by the query-argument <span class="code">
bolding</span></td>
<td>Zero to one</td>
</tr>

<tr><td><code><a href="#source">source</a></code></td>
<td>Comma-separated list of source fields of this result summary field.</td>
<td>Zero to one</td>
</tr>

<tr><td><code><a href="#to">to</a></code></td>
<td>Comma-separated list of the document summaries this should be
added to.</td>
<td>Zero to one</td>
</tr>
</table>

<p>Full summary is the default. Long field values (like document
content fields) should be made dynamic abstracts.</p>



<h2 id="weight">weight</h2>
<p>Contained in <code><a
href="#field">field</a></code>.</p>

<p>The weight of this field.
The field weight is for instance used when calculating the <code>nativeRank</code> score.</p>
<pre>
weight: [positive integer]
</pre>



<h2 id="weightedset">weightedset</h2>
<p>Contained in <code><a
href="#field">field</a></code> of type weightedset.</p>

<p>Properties of a weighted set.</p>
<pre>
weightedset: [property]
</pre>

<p>
or
</p>

<pre>
weightedset {
	[property]
	[property]
	&hellip;
}
</pre>

<table>
<tr><th>Property</th><th>Description</th><th>Occurrence</th></tr>

<tr><td><code>create-if-nonexistent</code></td>
<td>If the weight of a key is adjusted in a document using a partial update increment or decrement command, but the key
is currently not present, the command will be ignored by default. Set this to make keys to be created in this case instead.
This is useful when the weight is used to represent the count of the key.</td>
<td>Zero to one</td>
</tr>

<tr><td><code>remove-if-zero</code></td>
<td>This is the companion of <code>create-if-nonexistent</code> for the converse case: By default keys may have zero as
weight. With this turned on, keys whose weight is adjusted (or set) to zero, will be removed.</td>
<td>Zero to one</td>
</tr>

</table>



<h2 id="full">full</h2>
<p>Contained in <code><a
href="#summary">summary</a></code>.</p>

<p>Include the complete value of this summary field in the
summary returned in results.</p>

<pre>
full
</pre>



<h2 id="dynamic">dynamic</h2>
<p>Contained in <code><a
href="#summary">summary</a></code>.</p>

<pre>
dynamic
</pre>
<p>
    Make the value returned in results from this summary field be a <em>dynamic abstract</em> of the source summary
    field by extracting fragments of text around matching words. Matching words will also be highlighted, in
    similarity with the bolding feature. The default XML tag used to highlight the search terms is
    <code>&lt;hi&gt;</code>.</p>
<p>
    The XML tags used to highlight search terms in the result template, and the snippet separator, can be configured by
    overriding the container.qr-searchers configuration in <a href="services-search.html#sec-1">services.xml</a>.
    E.g. using &lt;b&gt;:

<pre class="brush: xml">
&lt;jdisc&gt;
  &lt;search&gt;
    &lt;config name="container.qr-searchers"&gt;
      &lt;tag&gt;
        &lt;bold&gt;
          &lt;open&gt;&amp;lt;b&amp;gt;&lt;/open&gt;
          &lt;close&gt;&amp;lt;/b&amp;gt;&lt;/close&gt;
        &lt;/bold&gt;
        &lt;separator&gt;...&lt;/separator&gt;
      &lt;/tag&gt;
    &lt;/config&gt;
  &lt;search&gt;
&lt;jdisc&gt;
</pre>
</p>



<h2 id="source">source</h2>
<p>Contained in <code><a
href="#summary">summary</a></code>.</p>

<p>Specifies
the name of the field or fields from which the value of this summary
field should be fetched. If multiple fields are specified, the value
will be taken from the first field if that has a value, from the
second if the first one is empty and so on.</p>
<pre>
source: [field-name], [field-name], &hellip;
</pre>
<p>When this is not specified, the source field is assumed to be the
field with the same name as the summary field.</p>



<h2 id="to">to</h2>
<p>Contained in <code><a href="#summary">summary</a></code>.</p>

<p>Specifies
the name of the document summaries this should be included in. An
alternative form to summary-to in summaries.</p>
<pre>
to: [document-summary-name], [document-summary-name], &hellip;
</pre>
<p>This can only be specified in fields, not in explicit document
summaries. When this is not specified, the field will go to the
<code>default</code> document summary.</p>



<h2 id="annotation">annotation</h2>
<p>Contained in <code><a href="#search">search</a></code>.</p>

<p>Defines an annotation type, to be used by the <a href="../annotations.html">Annotations API</a>. A
name of the annotation is mandatory, the body is optional.
</p>

<pre>
annotation [name] {
    [body]
}
</pre>


<h1 id="field_types">Field types</h1>

<p>
This section lists the field types and explains how each type is
handled by Vespa.
</p>


<h2 id="type:string">type:string</h2>

<dl class="blockindent">
<dt>Usage</dt>
<dd>Use for a text field of any length.<dd>

<dt>Indexing</dt>
<dd>By default, strings are <em>tokenized</em> before
indexing. Tokenization removes any non-word characters, and splits the
string into <em>tokens</em> on each word boundary. In addition, CJK
tokens are split using a <em>segmentation</em> algorithm. The resulting
tokens are what is becoming searchable in the index. To index strings
as-is (that is, avoid tokenization), use
<code><a href="#indexing-rewrite">indexing-rewrite</a>:
none</code>.
By default, strings are also normalized and stemmed.
</dd>

<dt>Summary</dt>
<dd>Added as-is.</dd>

<dt>Attribute</dt>
<dd>Added as-is. <a href="#match">match</a> exact or prefix is
supported types of searches in string attributes. Searches are however
case-insensitive. A query for <code>BritneY.spears</code> will match a
document containing <code>BrItNeY.SpEars</code></dd>
</dl>


<h2 id="type:int">type:int</h2>

<dl class="blockindent">
<dt>Usage</dt>
<dd>Use for single 32-bit integers.</dd>

<dt>Indexing</dt>
<dd>Not supported. An attribute will automatically be used instead.</dd>

<dt>Summary</dt>
<dd>Added as a 32-bit integer.</dd>

<dt>Attribute</dt>
<dd>Becomes integer attributes, which
supports range grouping and range searches.</dd>
</dl>


<h2 id="type:long">type:long</h2>

<dl class="blockindent">
<dt>Usage</dt>
<dd> Use for single 64-bit integers.</dd>

<dt>Indexing</dt>
<dd>Not supported. An attribute will automatically be used instead.</dd>

<dt>Summary</dt>
<dd> Added as a 64-bit integer.</dd>

<dt>Attribute</dt>
<dd> Becomes a 64-bit integer attribute, which
supports range grouping and range searches.</dd>
</dl>


<h2 id="type:byte">type:byte</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use for single 8-bit numbers.</dd>

<dt>Indexing</dt>
<dd>Not supported. An attribute will automatically be used instead.</dd>

<dt>Summary</dt><dd> Added as a byte.</dd>

<dt>Attribute</dt><dd> Added as a byte which supports range searches.</dd>
</dl>





<h2 id="type:float">type:float</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use for floating point numbers (32-bit IEEE 754 float).</dd>

<dt>Indexing</dt>
<dd>Not supported. An attribute will automatically be used instead.</dd>

<dt>Summary</dt><dd> Added as a 32-bit IEEE 754 float.</dd>

<dt>Attribute</dt><dd> Added as a 32-bit IEEE 754 float which supports range searches.</dd>
</dl>





<h2 id="type:double">type:double</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use for high precision floating point numbers (64-bit
IEEE 754 double).</dd>

<dt>Indexing</dt>
<dd>Not supported. An attribute will automatically be used instead.</dd>

<dt>Summary</dt><dd> Added as a 64-bit IEEE 754 double.</dd>

<dt>Attribute</dt><dd> Added as a 64-bit IEEE 754 double which supports range searches.</dd>
</dl>


<h2 id="type:predicate">type:position</h2>
<dl class="blockindent">
  <dt>Usage</dt><dd>Use to rank documents by distance to query. See <a href="../distance-sorting.html">distance sorting.</a></dd>
  <dt>Indexing</dt><dd>Not supported.</dd>
  <dt>Summary</dt><dd>Added as-is.</dd>
  <dt>Attribute</dt><dd>Added as an interleaved 64-bit integer (see <a href="http://en.wikipedia.org/wiki/Z-order_curve">Z-order curve</a>).</dd>
</dl>


<h2 id="type:predicate">type:predicate</h2>
<dl class="blockindent">
  <dt>Usage</dt><dd>Use to match queries to a set of boolean constraints. See <a href="../boolean-search.html#queries">boolean search.</a></dd>
  <dt>Indexing</dt>Indexed in a variable size binary format that is optimized for application during query evaluation.<dd></d>
  <dt>Summary</dt><dd>Added as-is.</dd>
  <dt>Attribute</dt><dd>Not supported.</dd>
</dl>


<h2 id="type:raw">type:raw</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use for binary data.</dd>

<dt>Indexing</dt><dd> Not supported.</dd>

<dt>Summary</dt><dd> Added as raw data.</dd>

<dt>Attribute</dt><dd> Not supported.</dd>
</dl>


<h2 id="type:uri">type:uri</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use for URLs.</dd>

<dt>Indexing</dt><dd>
<p>
The URL is split into the different components which are indexed
separately. Note that only URLs can be indexed this way, not other URIs.
The different components are as defined by the HTTP standard:
Scheme, hostname, port, path, query and fragment.
</p>

<p>For example, the URL</p>

<pre>
http://mysite.mydomain.com:8080/path/shop?d=hab&amp;id=1804905709&amp;cat=100#frag1
</pre>

<p>will be indexed as follows:</p>
<ul>
<li>scheme: http</li>
<li>hostname: mysite.mydomain.com (indexed as "mysite", "mydomain" and "com")</li>
<li>port: 8080 (note that port numbers 80 and 443 are not indexed, as they are the normal port numbers)</li>
<li>path: /path/shop (indexed as "path" and "shop")</li>
<li>query: d=hab&amp;id=1804905709&amp;cat=100 (indexed as "d", "hab", "id", "1804905709", "cat" and "100")</li>
<li>fragment: frag1</li>
</ul>

<p>
The syntax for searching these different components are
</p>

<pre>
[field-name].[component-name]:term
</pre>

<p>
For example, if you have a uri field <code>sourceurl</code>, you can search for
documents from slashdot using
</p>

<pre>
query=sourceurl.hostname:slashdot
</pre>

<p>
URL hostnames also support <em>anchored searching</em>, see
<a href="../reference/query-language-syntax.html#url_field">search in URL
fields</a>.</p>

<p>
It is not possible to index uri-typed fields into a common index, i.e. it has
to be indexed separately from other fields. If you need to combine URLs
with other fields you could store it in a string-field instead, but then
you can not search in the different parts of the URL (scheme, hostname,
port, path, query and fragment).</p>

<p>
<strong>Aliasing</strong> also works slightly different with URL fields - you
are allowed to create aliases both to the index (as usual) and to the
components of it. Use</p>

<pre>
alias [component]: [alias]
</pre>

<p>
to create an alias to a component. For example, given this field:
</p>

<pre>
field surl type uri {
    indexing: summary | index
    alias: url
    alias hostname: site
}
</pre>

<p>
a search in "surl" and "url" will search in the entire url,
while "surl.hostname" or "site" will search the hostname.
</p>
</dd>

<dt>Summary</dt><dd> Added as-is as a string.</dd>

<dt>Attribute</dt><dd> Added as-is as a string.</dd>
</dl>

<h2 id="type:array">type:array&lt;element-type&gt;</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use to create a multi-value field of the element type.
The element type can be any single value type, but not a nested array or weighted set.
</dd>

<dt>Indexing</dt><dd> Each element is indexed separately.</dd>

<dt>Summary</dt><dd> Added as a multi-value summary field.</dd>

<dt>Attribute</dt><dd> Added as a multi-value attribute.</dd>
</dl>

<h2 id="type:map">type:map&lt;key-type,value-type&gt;</h2>
<dl class="blockindent">
<dt>Usage</dt><dd> Use to create a normal map of values. You can use any other Vespa type as
both key and value. Maps are <strong>only available for streaming search</strong> at this time.

<p>
The following map configuration:
</p>
<pre class="code">
field mymap type map&lt;string, string&gt; {
}
</pre>
<p>
is similar to:
</p>
<pre class="code">
struct mystruct {
	field key type string { }
	field value type string { }
}
field mymap type array<mystruct> {
}
</pre>
</dd>
<dt>Indexing</dt><dd> A map is indexed as a struct with a key and value field with key-type and value-type as types, respectively.
</dd>

<dt>Summary</dt><dd> Both key and value have their own summary configuration.</dd>
</dl>

<h2 id="type:weightedset">type:weightedset&lt;element-type&gt;</h2>

<dl class="blockindent">
<dt>Usage</dt><dd>
<p>
Use to create a multi-value field of the element type,
where each element is assigned a signed 32-bit integer weight.
The element type can be any single value type, but not a nested array or weighted set.
</p>

<p>The weights may be assigned any semantics by the application. Two
main use cases:</p>

<ol type="I">
	<li>The weight symbolizes the number of occurrences</li>
	<li>The weight specifies another value type, for instance the
	importance of the document</li>
</ol>


<p>The weight of a matching value is by default used in <code>nativeRank</code> directly as the rank score of the field.
It is also possible to create a rank type which uses a rank boost table,
<code>weightboost</code> to calculate the rank value from the weight (the tags rank type does
this by default).</p>

<p>The weights are returned in the summary for the attribute. The
format of the field in the attribute summary is as in the example below:</p>

<pre>
&lt;field name="some_field"&gt;
    &lt;item weight="1"&gt;a&lt;/item&gt;
    &lt;item weight="10"&gt;b&lt;/item&gt;
    &lt;item weight="100"&gt;c&lt;/item&gt;
&lt;/field&gt;
</pre>

<p>
	It is possible to specify that
	a new key should be created if it does not exist before the
	update, and that it should be removed if the weight is set to
	zero. This is only usable together with the <code>increment</code>
	and <code>decrement</code> operations, described in <a
	href="../partial-update.html#operations">Updating documents:
	Operations</a>.
</p>
</dd>

<dt>Indexing</dt><dd>Each token present in the field is indexed separately. Information
indexed includes element number, element weight and a list of token occurrence positions
for each element in which the token is present.</dd>

<dt>Summary</dt><dd> Added as a multi-value summary field if this is an attribute.</dd>

<dt>Attribute</dt><dd> Added as a multi-value weighted attribute.</dd>
</dl>




<h2 id="type:tag">type:tag</h2>

<dl class="blockindent">
<dt>Usage</dt><dd>
<p> Use to create a multi-value field giving regular tagging semantics.
Use this if</p>

<ul>
<li>you want a field where tags can be added and removed
without updating the whole document, or the whole set of tags</li>
<li>the number of times the tags are added matters for relevancy</li>
<li>tags should be matched exactly in searches, but can not include space</li>
</ul>


<p>
Using the tag type as follows
</p>
<pre>
field mytags type tag {
	indexing: attribute | summary
}
</pre>

<p>
is equivalent to
</p>
<pre>
field mytags type weightedset&lt;string&gt; {
	indexing: attribute | summary
	weightedset {
		create-if-nonexistent
		remove-if-zero
	}
	match: word
	rank-type: tags
}
</pre>

<p>The tag rank type makes the default score in <code>nativeRank</code> increase quickly initially as the count of a matched tag increases,
then progressively more slowly as the count of the tag continues to increase.
</p>
</dd>

<dt>Indexing</dt><dd> Should not be indexed (is searchable as an attribute).</dd>

<dt>Summary</dt><dd> The tags will be visible in the summary as a multi-value field (if
summary is added to the tag indexing statement)</dd>

<dt>Attribute</dt><dd> A <em>weighted set</em> of <em>searchable, updateable, exactly matched (case-insensitive) strings</em>
with create-if-nonexistent and remove-if-zero semantics (see <a href="#weightedset">weightedset</a>).Matching is case-insensitive.</dd>
</dl>


<h2 id="type:tensor">type:tensor</h2>

<dl class="blockindent">
<dt>Usage</dt><dd>
<p>Use to create a tensor field that can be used for ranking.<br>
See <a href="../reference/tensor.html">Tensor Evaluation Reference</a> for definition of tensors and
<a href="../reference/document-json-format.html#tensor">Document JSON Format</a> for the JSON feed format for tensors.</p>

</dd>

<dt>Indexing</dt><dd>Not supported.</dd>

<dt>Summary</dt><dd>Added as-is.
The JSON result format (<code>presentation.format=json</code>) should be used when returning a summary class containing a tensor field as part of search.</dd>

<dt>Attribute</dt><dd>Added as-is in an attribute to be used for ranking.
Note that a tensor field is not searchable.</dd>
</dl>


<h2 id="type:struct">type:struct</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use to define a field with a struct datatype. Structs are only available for streaming search.
To define a struct field, you must first create a <a href="#struct">struct definition</a></dd>

<dt>Indexing</dt><dd> Each field in the struct is indexed according to its own configuration </dd>

<dt>Summary</dt><dd> Each field in the struct has its own summary configuration</dd>

<dt>Attribute</dt><dd>
<p>
Each field may or may not be an attribute according to its configuration.
</p>
<p>
The <a href="#struct">struct</a> must be defined inside the document definition. To declare a struct field in
a document or struct, use the struct name to identify the field type:
</p>

<pre>field foo type address {}</pre>
</dd>
</dl>


<h2 id="type:annotationreference">type:annotationreference</h2>

<dl class="blockindent">
<dt>Usage</dt><dd> Use to define a field (inside <a href="#annotation">annotation</a>, or inside e.g. a
struct used by a field in an <a href="#annotation">annotation</a>) with a reference to another annotation.
To define a such a field, you must first create an <a href="#annotation">annotation type</a></dd>

<dt>Indexing</dt><dd> N/A. </dd>

<dt>Summary</dt><dd> N/A. </dd>

<dt>Attribute</dt><dd>
<p>
N/A.
</p>
<p>
The <a href="#annotation">struct</a> must be defined inside the search definition. To declare an annotationreference field in
an annotation, use the annotation name to identify the field type:
</p>

<pre>annotation foo {
  field baz type annotationreference&lt;bar&gt; { }
}
annotation bar { }</pre>
</dd>
</dl>



<h1 id="Document and search field types">Document and search field types</h1>

<p>Note that it is possible to make a document field
of one type into one or more instances of another search field, by
declaring a field outside the document, which uses other fields as
input. For example, to create an integer attribute for a
string containing a comma-separated list of integers in the document,
do like this:</p>

<pre class="code">
search example {
  document example {
    field yearlist type string { # Comma-separated years
      &hellip;
    }
    &hellip;
  }

  field year type array&lt;int&gt; { # Search field using the yearlist value
    indexing: input yearlist | split "," | attribute
  }
}
</pre>


<h1 id="an_example">An example</h1>

<p>Here is an example of a complete search definition:</p>

<pre class="code">
search example {

  # This documents inherits the fields of two others
  document example inherits mysuperdocument, another {

    field title type string {
      indexing: summary | index
      alias: analias.totitle
      alias default: analias_todefault
    }

    field description type string {
      indexing: summary | index
    }

    field author type string {
      indexing: summary | index
      # author names only, so no stemming
      stemming: none
    }

    field category type string {
      indexing: summary | attribute
      attribute: fast-search
      match: exact
    }

    field popularity type int {
      indexing: summary | attribute
    }

    field measurement type int {
      indexing: summary | attribute
    }

    # Index each category token separately, do not tokenize categories
    field categories type string {
      indexing {
        input categories | split "," | normalize | join " " | index
      }
      indexing-rewrite: none;
      body  # Assume one document may have thousands of categories&hellip;
    }

    # Categories as an array - preferrable
    field morecategories type array&lt;string&gt; {
      indexing: index
    }

    #restrict document access
    field permissions type array&lt;byte&gt; {
      indexing: input permissions . input geoperms . input adultness | summary | attribute
      attribute: fast-search
    }
    #placeholder - elements added to global permissions
    field geoperms type array&lt;byte&gt; {

    }
    #placeholder - elements added to global permissions
    field adultness type array&lt;byte&gt; {

    }
  }

  fieldset default {
    fields: title, description
  }

  # Additional default settings
  rank-profile default inherits default {
    first-phase {
        expression: nativeRank
    }
    second-phase {
      expression {
          0.5 * 0.5 * (0.1 * attribute(popularity) + fieldMatch(description))
          + 0.2 * attributeMatch(category)
          + 0.3 * fieldMatch(title)
      }
      rerank-count: 200
    }
  }

  # Some experimental ranking changes
  rank-profile experimental inherits default {
    second-phase {
      expression {
          0.5 * 0.5 * (attribute(measurement) * attribute(popularity) + fieldMatch(description))
          + 0.2 * attributeMatch(category)
          + 0.3 * fieldMatch(title)
      }
    }
  }

  # Ranking expression from separate file (filename mlrrank.expression, in the same directory as the sd-file)
  rank-profile mlrraning inherits default {
    second-phase {
      expression: file:mlrrank
    }
  }

  rank-profile other inherits experimental {
    second-phase {
      rerank-count: 100
    }
  }

  rank-profile justthebest {
    match-phase {
      attribute: popularity
      max-hits: 10000
      diversity {
        attribute: category
        min-groups: 20
      }
    }
    first-phase {
      expression: nativeRank + 0.1 * attribute(popularity)
    }
    second-phase {
      expression {
          0.5 * 0.5 * (0.1 * attribute(popularity) + fieldMatch(description))
          + 0.2 * attributeMatch(category)
          + 0.3 * fieldMatch(title)
      }
    }
  }

  # A derived field defined outside a document,
  # note how each indexing statement
  # fetches a value to index
  field exact type string {
    indexing {
      input title | summary | index;
      input category | summary | index;
    }
    stemming: none
    normalizing: none
    match {
        exact
	exact-terminator: "@@"
    }
  }

}
</pre>

</body>
</html>
